
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model TypeItem
 * 
 */
export type TypeItem = {
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CostCenter
 * 
 */
export type CostCenter = {
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model KeyCountry
 * 
 */
export type KeyCountry = {
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Item
 * 
 */
export type Item = {
  id: number
  typeId: string
  ccId: string
  kcId: string
  purchaseId: number
  description: string
  quantity: number
  priceUnit: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  email: string
  password: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Vendor
 * 
 */
export type Vendor = {
  id: number
  codeSap: string
  name: string
  fiscalTaxId: string
  email: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PurchaseRequest
 * 
 */
export type PurchaseRequest = {
  id: number
  requesterId: number
  type: RequestType
  delivery: Condition
  description: string
  totalContract: number
  startContract: Date
  endContract: Date
  contract: string
  vendorId: number
  observation: string
  status: PurchaseStatus
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Approval
 * 
 */
export type Approval = {
  emailApprover: string
  status: boolean
  purchaseId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BankAccount
 * 
 */
export type BankAccount = {
  vendorId: number
  codeBank: string
  branch: string
  account: string
  digit: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model City
 * 
 */
export type City = {
  code: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model State
 * 
 */
export type State = {
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Country
 * 
 */
export type Country = {
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Address
 * 
 */
export type Address = {
  vendorId: number
  addressType: string
  street: string
  streetNo: number
  complement: string
  zipCode: string
  block: string
  cityId: number
  stateId: string
  countryId: string
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const RequestType: {
  New: 'New',
  Renewal: 'Renewal',
  Adjustment: 'Adjustment',
  Termination: 'Termination'
};

export type RequestType = (typeof RequestType)[keyof typeof RequestType]


export const Condition: {
  Recurrent: 'Recurrent',
  Spot: 'Spot'
};

export type Condition = (typeof Condition)[keyof typeof Condition]


export const PurchaseStatus: {
  Sent: 'Sent',
  Approved: 'Approved',
  Rejected: 'Rejected',
  Reported: 'Reported'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TypeItems
 * const typeItems = await prisma.typeItem.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TypeItems
   * const typeItems = await prisma.typeItem.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.typeItem`: Exposes CRUD operations for the **TypeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeItems
    * const typeItems = await prisma.typeItem.findMany()
    * ```
    */
  get typeItem(): Prisma.TypeItemDelegate<GlobalReject>;

  /**
   * `prisma.costCenter`: Exposes CRUD operations for the **CostCenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCenters
    * const costCenters = await prisma.costCenter.findMany()
    * ```
    */
  get costCenter(): Prisma.CostCenterDelegate<GlobalReject>;

  /**
   * `prisma.keyCountry`: Exposes CRUD operations for the **KeyCountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyCountries
    * const keyCountries = await prisma.keyCountry.findMany()
    * ```
    */
  get keyCountry(): Prisma.KeyCountryDelegate<GlobalReject>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<GlobalReject>;

  /**
   * `prisma.purchaseRequest`: Exposes CRUD operations for the **PurchaseRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseRequests
    * const purchaseRequests = await prisma.purchaseRequest.findMany()
    * ```
    */
  get purchaseRequest(): Prisma.PurchaseRequestDelegate<GlobalReject>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<GlobalReject>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.14.0
   * Query Engine version: 2b0c12756921c891fec4f68d9444e18c7d5d4a6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    TypeItem: 'TypeItem',
    CostCenter: 'CostCenter',
    KeyCountry: 'KeyCountry',
    Item: 'Item',
    User: 'User',
    Vendor: 'Vendor',
    PurchaseRequest: 'PurchaseRequest',
    Approval: 'Approval',
    BankAccount: 'BankAccount',
    City: 'City',
    State: 'State',
    Country: 'Country',
    Address: 'Address'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TypeItemCountOutputType
   */


  export type TypeItemCountOutputType = {
    typeItems: number
  }

  export type TypeItemCountOutputTypeSelect = {
    typeItems?: boolean
  }

  export type TypeItemCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TypeItemCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TypeItemCountOutputType
    : S extends undefined
    ? never
    : S extends TypeItemCountOutputTypeArgs
    ?'include' extends U
    ? TypeItemCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TypeItemCountOutputType ? TypeItemCountOutputType[P] : never
  } 
    : TypeItemCountOutputType
  : TypeItemCountOutputType




  // Custom InputTypes

  /**
   * TypeItemCountOutputType without action
   */
  export type TypeItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TypeItemCountOutputType
     * 
    **/
    select?: TypeItemCountOutputTypeSelect | null
  }



  /**
   * Count Type CostCenterCountOutputType
   */


  export type CostCenterCountOutputType = {
    typeItems: number
  }

  export type CostCenterCountOutputTypeSelect = {
    typeItems?: boolean
  }

  export type CostCenterCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CostCenterCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CostCenterCountOutputType
    : S extends undefined
    ? never
    : S extends CostCenterCountOutputTypeArgs
    ?'include' extends U
    ? CostCenterCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CostCenterCountOutputType ? CostCenterCountOutputType[P] : never
  } 
    : CostCenterCountOutputType
  : CostCenterCountOutputType




  // Custom InputTypes

  /**
   * CostCenterCountOutputType without action
   */
  export type CostCenterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CostCenterCountOutputType
     * 
    **/
    select?: CostCenterCountOutputTypeSelect | null
  }



  /**
   * Count Type KeyCountryCountOutputType
   */


  export type KeyCountryCountOutputType = {
    typeItems: number
  }

  export type KeyCountryCountOutputTypeSelect = {
    typeItems?: boolean
  }

  export type KeyCountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | KeyCountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? KeyCountryCountOutputType
    : S extends undefined
    ? never
    : S extends KeyCountryCountOutputTypeArgs
    ?'include' extends U
    ? KeyCountryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof KeyCountryCountOutputType ? KeyCountryCountOutputType[P] : never
  } 
    : KeyCountryCountOutputType
  : KeyCountryCountOutputType




  // Custom InputTypes

  /**
   * KeyCountryCountOutputType without action
   */
  export type KeyCountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KeyCountryCountOutputType
     * 
    **/
    select?: KeyCountryCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    purchaseRequests: number
  }

  export type UserCountOutputTypeSelect = {
    purchaseRequests?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorCountOutputType
   */


  export type VendorCountOutputType = {
    purchaseRequests: number
    bankAccounts: number
    addresses: number
  }

  export type VendorCountOutputTypeSelect = {
    purchaseRequests?: boolean
    bankAccounts?: boolean
    addresses?: boolean
  }

  export type VendorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VendorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VendorCountOutputType
    : S extends undefined
    ? never
    : S extends VendorCountOutputTypeArgs
    ?'include' extends U
    ? VendorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VendorCountOutputType ? VendorCountOutputType[P] : never
  } 
    : VendorCountOutputType
  : VendorCountOutputType




  // Custom InputTypes

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     * 
    **/
    select?: VendorCountOutputTypeSelect | null
  }



  /**
   * Count Type PurchaseRequestCountOutputType
   */


  export type PurchaseRequestCountOutputType = {
    typeItems: number
    approvals: number
  }

  export type PurchaseRequestCountOutputTypeSelect = {
    typeItems?: boolean
    approvals?: boolean
  }

  export type PurchaseRequestCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PurchaseRequestCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PurchaseRequestCountOutputType
    : S extends undefined
    ? never
    : S extends PurchaseRequestCountOutputTypeArgs
    ?'include' extends U
    ? PurchaseRequestCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PurchaseRequestCountOutputType ? PurchaseRequestCountOutputType[P] : never
  } 
    : PurchaseRequestCountOutputType
  : PurchaseRequestCountOutputType




  // Custom InputTypes

  /**
   * PurchaseRequestCountOutputType without action
   */
  export type PurchaseRequestCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequestCountOutputType
     * 
    **/
    select?: PurchaseRequestCountOutputTypeSelect | null
  }



  /**
   * Count Type CityCountOutputType
   */


  export type CityCountOutputType = {
    addresses: number
  }

  export type CityCountOutputTypeSelect = {
    addresses?: boolean
  }

  export type CityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CityCountOutputType
    : S extends undefined
    ? never
    : S extends CityCountOutputTypeArgs
    ?'include' extends U
    ? CityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CityCountOutputType ? CityCountOutputType[P] : never
  } 
    : CityCountOutputType
  : CityCountOutputType




  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     * 
    **/
    select?: CityCountOutputTypeSelect | null
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    addresses: number
  }

  export type StateCountOutputTypeSelect = {
    addresses?: boolean
  }

  export type StateCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StateCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StateCountOutputType
    : S extends undefined
    ? never
    : S extends StateCountOutputTypeArgs
    ?'include' extends U
    ? StateCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StateCountOutputType ? StateCountOutputType[P] : never
  } 
    : StateCountOutputType
  : StateCountOutputType




  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     * 
    **/
    select?: StateCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    addresses: number
  }

  export type CountryCountOutputTypeSelect = {
    addresses?: boolean
  }

  export type CountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountryCountOutputType
    : S extends undefined
    ? never
    : S extends CountryCountOutputTypeArgs
    ?'include' extends U
    ? CountryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CountryCountOutputType ? CountryCountOutputType[P] : never
  } 
    : CountryCountOutputType
  : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     * 
    **/
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model TypeItem
   */


  export type AggregateTypeItem = {
    _count: TypeItemCountAggregateOutputType | null
    _min: TypeItemMinAggregateOutputType | null
    _max: TypeItemMaxAggregateOutputType | null
  }

  export type TypeItemMinAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeItemMaxAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeItemCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeItemMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeItemMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeItemCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeItemAggregateArgs = {
    /**
     * Filter which TypeItem to aggregate.
     * 
    **/
    where?: TypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeItems to fetch.
     * 
    **/
    orderBy?: Enumerable<TypeItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeItems
    **/
    _count?: true | TypeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeItemMaxAggregateInputType
  }

  export type GetTypeItemAggregateType<T extends TypeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeItem[P]>
      : GetScalarType<T[P], AggregateTypeItem[P]>
  }




  export type TypeItemGroupByArgs = {
    where?: TypeItemWhereInput
    orderBy?: Enumerable<TypeItemOrderByWithAggregationInput>
    by: Array<TypeItemScalarFieldEnum>
    having?: TypeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeItemCountAggregateInputType | true
    _min?: TypeItemMinAggregateInputType
    _max?: TypeItemMaxAggregateInputType
  }


  export type TypeItemGroupByOutputType = {
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TypeItemCountAggregateOutputType | null
    _min: TypeItemMinAggregateOutputType | null
    _max: TypeItemMaxAggregateOutputType | null
  }

  type GetTypeItemGroupByPayload<T extends TypeItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TypeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeItemGroupByOutputType[P]>
            : GetScalarType<T[P], TypeItemGroupByOutputType[P]>
        }
      >
    >


  export type TypeItemSelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | TypeItemCountOutputTypeArgs
  }

  export type TypeItemInclude = {
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | TypeItemCountOutputTypeArgs
  }

  export type TypeItemGetPayload<
    S extends boolean | null | undefined | TypeItemArgs,
    U = keyof S
      > = S extends true
        ? TypeItem
    : S extends undefined
    ? never
    : S extends TypeItemArgs | TypeItemFindManyArgs
    ?'include' extends U
    ? TypeItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? TypeItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? TypeItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TypeItem ? TypeItem[P] : never
  } 
    : TypeItem
  : TypeItem


  type TypeItemCountArgs = Merge<
    Omit<TypeItemFindManyArgs, 'select' | 'include'> & {
      select?: TypeItemCountAggregateInputType | true
    }
  >

  export interface TypeItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TypeItem that matches the filter.
     * @param {TypeItemFindUniqueArgs} args - Arguments to find a TypeItem
     * @example
     * // Get one TypeItem
     * const typeItem = await prisma.typeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypeItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypeItem'> extends True ? CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>> : CheckSelect<T, Prisma__TypeItemClient<TypeItem | null >, Prisma__TypeItemClient<TypeItemGetPayload<T> | null >>

    /**
     * Find the first TypeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemFindFirstArgs} args - Arguments to find a TypeItem
     * @example
     * // Get one TypeItem
     * const typeItem = await prisma.typeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypeItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypeItem'> extends True ? CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>> : CheckSelect<T, Prisma__TypeItemClient<TypeItem | null >, Prisma__TypeItemClient<TypeItemGetPayload<T> | null >>

    /**
     * Find zero or more TypeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeItems
     * const typeItems = await prisma.typeItem.findMany()
     * 
     * // Get first 10 TypeItems
     * const typeItems = await prisma.typeItem.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const typeItemWithCodeOnly = await prisma.typeItem.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends TypeItemFindManyArgs>(
      args?: SelectSubset<T, TypeItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TypeItem>>, PrismaPromise<Array<TypeItemGetPayload<T>>>>

    /**
     * Create a TypeItem.
     * @param {TypeItemCreateArgs} args - Arguments to create a TypeItem.
     * @example
     * // Create one TypeItem
     * const TypeItem = await prisma.typeItem.create({
     *   data: {
     *     // ... data to create a TypeItem
     *   }
     * })
     * 
    **/
    create<T extends TypeItemCreateArgs>(
      args: SelectSubset<T, TypeItemCreateArgs>
    ): CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>>

    /**
     * Create many TypeItems.
     *     @param {TypeItemCreateManyArgs} args - Arguments to create many TypeItems.
     *     @example
     *     // Create many TypeItems
     *     const typeItem = await prisma.typeItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeItemCreateManyArgs>(
      args?: SelectSubset<T, TypeItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TypeItem.
     * @param {TypeItemDeleteArgs} args - Arguments to delete one TypeItem.
     * @example
     * // Delete one TypeItem
     * const TypeItem = await prisma.typeItem.delete({
     *   where: {
     *     // ... filter to delete one TypeItem
     *   }
     * })
     * 
    **/
    delete<T extends TypeItemDeleteArgs>(
      args: SelectSubset<T, TypeItemDeleteArgs>
    ): CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>>

    /**
     * Update one TypeItem.
     * @param {TypeItemUpdateArgs} args - Arguments to update one TypeItem.
     * @example
     * // Update one TypeItem
     * const typeItem = await prisma.typeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeItemUpdateArgs>(
      args: SelectSubset<T, TypeItemUpdateArgs>
    ): CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>>

    /**
     * Delete zero or more TypeItems.
     * @param {TypeItemDeleteManyArgs} args - Arguments to filter TypeItems to delete.
     * @example
     * // Delete a few TypeItems
     * const { count } = await prisma.typeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeItemDeleteManyArgs>(
      args?: SelectSubset<T, TypeItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeItems
     * const typeItem = await prisma.typeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeItemUpdateManyArgs>(
      args: SelectSubset<T, TypeItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeItem.
     * @param {TypeItemUpsertArgs} args - Arguments to update or create a TypeItem.
     * @example
     * // Update or create a TypeItem
     * const typeItem = await prisma.typeItem.upsert({
     *   create: {
     *     // ... data to create a TypeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeItem we want to update
     *   }
     * })
    **/
    upsert<T extends TypeItemUpsertArgs>(
      args: SelectSubset<T, TypeItemUpsertArgs>
    ): CheckSelect<T, Prisma__TypeItemClient<TypeItem>, Prisma__TypeItemClient<TypeItemGetPayload<T>>>

    /**
     * Count the number of TypeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemCountArgs} args - Arguments to filter TypeItems to count.
     * @example
     * // Count the number of TypeItems
     * const count = await prisma.typeItem.count({
     *   where: {
     *     // ... the filter for the TypeItems we want to count
     *   }
     * })
    **/
    count<T extends TypeItemCountArgs>(
      args?: Subset<T, TypeItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeItemAggregateArgs>(args: Subset<T, TypeItemAggregateArgs>): PrismaPromise<GetTypeItemAggregateType<T>>

    /**
     * Group by TypeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeItemGroupByArgs['orderBy'] }
        : { orderBy?: TypeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeItemGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypeItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    typeItems<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TypeItem findUnique
   */
  export type TypeItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * Throw an Error if a TypeItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TypeItem to fetch.
     * 
    **/
    where: TypeItemWhereUniqueInput
  }


  /**
   * TypeItem findFirst
   */
  export type TypeItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * Throw an Error if a TypeItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TypeItem to fetch.
     * 
    **/
    where?: TypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeItems to fetch.
     * 
    **/
    orderBy?: Enumerable<TypeItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeItems.
     * 
    **/
    cursor?: TypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeItems.
     * 
    **/
    distinct?: Enumerable<TypeItemScalarFieldEnum>
  }


  /**
   * TypeItem findMany
   */
  export type TypeItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * Filter, which TypeItems to fetch.
     * 
    **/
    where?: TypeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeItems to fetch.
     * 
    **/
    orderBy?: Enumerable<TypeItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeItems.
     * 
    **/
    cursor?: TypeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TypeItemScalarFieldEnum>
  }


  /**
   * TypeItem create
   */
  export type TypeItemCreateArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * The data needed to create a TypeItem.
     * 
    **/
    data: XOR<TypeItemCreateInput, TypeItemUncheckedCreateInput>
  }


  /**
   * TypeItem createMany
   */
  export type TypeItemCreateManyArgs = {
    /**
     * The data used to create many TypeItems.
     * 
    **/
    data: Enumerable<TypeItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypeItem update
   */
  export type TypeItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * The data needed to update a TypeItem.
     * 
    **/
    data: XOR<TypeItemUpdateInput, TypeItemUncheckedUpdateInput>
    /**
     * Choose, which TypeItem to update.
     * 
    **/
    where: TypeItemWhereUniqueInput
  }


  /**
   * TypeItem updateMany
   */
  export type TypeItemUpdateManyArgs = {
    /**
     * The data used to update TypeItems.
     * 
    **/
    data: XOR<TypeItemUpdateManyMutationInput, TypeItemUncheckedUpdateManyInput>
    /**
     * Filter which TypeItems to update
     * 
    **/
    where?: TypeItemWhereInput
  }


  /**
   * TypeItem upsert
   */
  export type TypeItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * The filter to search for the TypeItem to update in case it exists.
     * 
    **/
    where: TypeItemWhereUniqueInput
    /**
     * In case the TypeItem found by the `where` argument doesn't exist, create a new TypeItem with this data.
     * 
    **/
    create: XOR<TypeItemCreateInput, TypeItemUncheckedCreateInput>
    /**
     * In case the TypeItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TypeItemUpdateInput, TypeItemUncheckedUpdateInput>
  }


  /**
   * TypeItem delete
   */
  export type TypeItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
    /**
     * Filter which TypeItem to delete.
     * 
    **/
    where: TypeItemWhereUniqueInput
  }


  /**
   * TypeItem deleteMany
   */
  export type TypeItemDeleteManyArgs = {
    /**
     * Filter which TypeItems to delete
     * 
    **/
    where?: TypeItemWhereInput
  }


  /**
   * TypeItem without action
   */
  export type TypeItemArgs = {
    /**
     * Select specific fields to fetch from the TypeItem
     * 
    **/
    select?: TypeItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TypeItemInclude | null
  }



  /**
   * Model CostCenter
   */


  export type AggregateCostCenter = {
    _count: CostCenterCountAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  export type CostCenterMinAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterMaxAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCenterCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostCenterMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCenterCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostCenterAggregateArgs = {
    /**
     * Filter which CostCenter to aggregate.
     * 
    **/
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     * 
    **/
    orderBy?: Enumerable<CostCenterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCenters
    **/
    _count?: true | CostCenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCenterMaxAggregateInputType
  }

  export type GetCostCenterAggregateType<T extends CostCenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCenter[P]>
      : GetScalarType<T[P], AggregateCostCenter[P]>
  }




  export type CostCenterGroupByArgs = {
    where?: CostCenterWhereInput
    orderBy?: Enumerable<CostCenterOrderByWithAggregationInput>
    by: Array<CostCenterScalarFieldEnum>
    having?: CostCenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCenterCountAggregateInputType | true
    _min?: CostCenterMinAggregateInputType
    _max?: CostCenterMaxAggregateInputType
  }


  export type CostCenterGroupByOutputType = {
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CostCenterCountAggregateOutputType | null
    _min: CostCenterMinAggregateOutputType | null
    _max: CostCenterMaxAggregateOutputType | null
  }

  type GetCostCenterGroupByPayload<T extends CostCenterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CostCenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
            : GetScalarType<T[P], CostCenterGroupByOutputType[P]>
        }
      >
    >


  export type CostCenterSelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | CostCenterCountOutputTypeArgs
  }

  export type CostCenterInclude = {
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | CostCenterCountOutputTypeArgs
  }

  export type CostCenterGetPayload<
    S extends boolean | null | undefined | CostCenterArgs,
    U = keyof S
      > = S extends true
        ? CostCenter
    : S extends undefined
    ? never
    : S extends CostCenterArgs | CostCenterFindManyArgs
    ?'include' extends U
    ? CostCenter  & {
    [P in TrueKeys<S['include']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? CostCenterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? CostCenterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CostCenter ? CostCenter[P] : never
  } 
    : CostCenter
  : CostCenter


  type CostCenterCountArgs = Merge<
    Omit<CostCenterFindManyArgs, 'select' | 'include'> & {
      select?: CostCenterCountAggregateInputType | true
    }
  >

  export interface CostCenterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CostCenter that matches the filter.
     * @param {CostCenterFindUniqueArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CostCenterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CostCenterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CostCenter'> extends True ? CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>> : CheckSelect<T, Prisma__CostCenterClient<CostCenter | null >, Prisma__CostCenterClient<CostCenterGetPayload<T> | null >>

    /**
     * Find the first CostCenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindFirstArgs} args - Arguments to find a CostCenter
     * @example
     * // Get one CostCenter
     * const costCenter = await prisma.costCenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CostCenterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CostCenterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CostCenter'> extends True ? CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>> : CheckSelect<T, Prisma__CostCenterClient<CostCenter | null >, Prisma__CostCenterClient<CostCenterGetPayload<T> | null >>

    /**
     * Find zero or more CostCenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCenters
     * const costCenters = await prisma.costCenter.findMany()
     * 
     * // Get first 10 CostCenters
     * const costCenters = await prisma.costCenter.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const costCenterWithCodeOnly = await prisma.costCenter.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends CostCenterFindManyArgs>(
      args?: SelectSubset<T, CostCenterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CostCenter>>, PrismaPromise<Array<CostCenterGetPayload<T>>>>

    /**
     * Create a CostCenter.
     * @param {CostCenterCreateArgs} args - Arguments to create a CostCenter.
     * @example
     * // Create one CostCenter
     * const CostCenter = await prisma.costCenter.create({
     *   data: {
     *     // ... data to create a CostCenter
     *   }
     * })
     * 
    **/
    create<T extends CostCenterCreateArgs>(
      args: SelectSubset<T, CostCenterCreateArgs>
    ): CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>>

    /**
     * Create many CostCenters.
     *     @param {CostCenterCreateManyArgs} args - Arguments to create many CostCenters.
     *     @example
     *     // Create many CostCenters
     *     const costCenter = await prisma.costCenter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CostCenterCreateManyArgs>(
      args?: SelectSubset<T, CostCenterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CostCenter.
     * @param {CostCenterDeleteArgs} args - Arguments to delete one CostCenter.
     * @example
     * // Delete one CostCenter
     * const CostCenter = await prisma.costCenter.delete({
     *   where: {
     *     // ... filter to delete one CostCenter
     *   }
     * })
     * 
    **/
    delete<T extends CostCenterDeleteArgs>(
      args: SelectSubset<T, CostCenterDeleteArgs>
    ): CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>>

    /**
     * Update one CostCenter.
     * @param {CostCenterUpdateArgs} args - Arguments to update one CostCenter.
     * @example
     * // Update one CostCenter
     * const costCenter = await prisma.costCenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CostCenterUpdateArgs>(
      args: SelectSubset<T, CostCenterUpdateArgs>
    ): CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>>

    /**
     * Delete zero or more CostCenters.
     * @param {CostCenterDeleteManyArgs} args - Arguments to filter CostCenters to delete.
     * @example
     * // Delete a few CostCenters
     * const { count } = await prisma.costCenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CostCenterDeleteManyArgs>(
      args?: SelectSubset<T, CostCenterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCenters
     * const costCenter = await prisma.costCenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CostCenterUpdateManyArgs>(
      args: SelectSubset<T, CostCenterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CostCenter.
     * @param {CostCenterUpsertArgs} args - Arguments to update or create a CostCenter.
     * @example
     * // Update or create a CostCenter
     * const costCenter = await prisma.costCenter.upsert({
     *   create: {
     *     // ... data to create a CostCenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCenter we want to update
     *   }
     * })
    **/
    upsert<T extends CostCenterUpsertArgs>(
      args: SelectSubset<T, CostCenterUpsertArgs>
    ): CheckSelect<T, Prisma__CostCenterClient<CostCenter>, Prisma__CostCenterClient<CostCenterGetPayload<T>>>

    /**
     * Count the number of CostCenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterCountArgs} args - Arguments to filter CostCenters to count.
     * @example
     * // Count the number of CostCenters
     * const count = await prisma.costCenter.count({
     *   where: {
     *     // ... the filter for the CostCenters we want to count
     *   }
     * })
    **/
    count<T extends CostCenterCountArgs>(
      args?: Subset<T, CostCenterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCenterAggregateArgs>(args: Subset<T, CostCenterAggregateArgs>): PrismaPromise<GetCostCenterAggregateType<T>>

    /**
     * Group by CostCenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCenterGroupByArgs['orderBy'] }
        : { orderBy?: CostCenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCenterGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CostCenterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    typeItems<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CostCenter findUnique
   */
  export type CostCenterFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * Throw an Error if a CostCenter can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CostCenter to fetch.
     * 
    **/
    where: CostCenterWhereUniqueInput
  }


  /**
   * CostCenter findFirst
   */
  export type CostCenterFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * Throw an Error if a CostCenter can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CostCenter to fetch.
     * 
    **/
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     * 
    **/
    orderBy?: Enumerable<CostCenterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCenters.
     * 
    **/
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCenters.
     * 
    **/
    distinct?: Enumerable<CostCenterScalarFieldEnum>
  }


  /**
   * CostCenter findMany
   */
  export type CostCenterFindManyArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * Filter, which CostCenters to fetch.
     * 
    **/
    where?: CostCenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCenters to fetch.
     * 
    **/
    orderBy?: Enumerable<CostCenterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCenters.
     * 
    **/
    cursor?: CostCenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCenters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCenters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CostCenterScalarFieldEnum>
  }


  /**
   * CostCenter create
   */
  export type CostCenterCreateArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * The data needed to create a CostCenter.
     * 
    **/
    data: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
  }


  /**
   * CostCenter createMany
   */
  export type CostCenterCreateManyArgs = {
    /**
     * The data used to create many CostCenters.
     * 
    **/
    data: Enumerable<CostCenterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CostCenter update
   */
  export type CostCenterUpdateArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * The data needed to update a CostCenter.
     * 
    **/
    data: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
    /**
     * Choose, which CostCenter to update.
     * 
    **/
    where: CostCenterWhereUniqueInput
  }


  /**
   * CostCenter updateMany
   */
  export type CostCenterUpdateManyArgs = {
    /**
     * The data used to update CostCenters.
     * 
    **/
    data: XOR<CostCenterUpdateManyMutationInput, CostCenterUncheckedUpdateManyInput>
    /**
     * Filter which CostCenters to update
     * 
    **/
    where?: CostCenterWhereInput
  }


  /**
   * CostCenter upsert
   */
  export type CostCenterUpsertArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * The filter to search for the CostCenter to update in case it exists.
     * 
    **/
    where: CostCenterWhereUniqueInput
    /**
     * In case the CostCenter found by the `where` argument doesn't exist, create a new CostCenter with this data.
     * 
    **/
    create: XOR<CostCenterCreateInput, CostCenterUncheckedCreateInput>
    /**
     * In case the CostCenter was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CostCenterUpdateInput, CostCenterUncheckedUpdateInput>
  }


  /**
   * CostCenter delete
   */
  export type CostCenterDeleteArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
    /**
     * Filter which CostCenter to delete.
     * 
    **/
    where: CostCenterWhereUniqueInput
  }


  /**
   * CostCenter deleteMany
   */
  export type CostCenterDeleteManyArgs = {
    /**
     * Filter which CostCenters to delete
     * 
    **/
    where?: CostCenterWhereInput
  }


  /**
   * CostCenter without action
   */
  export type CostCenterArgs = {
    /**
     * Select specific fields to fetch from the CostCenter
     * 
    **/
    select?: CostCenterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CostCenterInclude | null
  }



  /**
   * Model KeyCountry
   */


  export type AggregateKeyCountry = {
    _count: KeyCountryCountAggregateOutputType | null
    _min: KeyCountryMinAggregateOutputType | null
    _max: KeyCountryMaxAggregateOutputType | null
  }

  export type KeyCountryMinAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyCountryMaxAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeyCountryCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeyCountryMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyCountryMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeyCountryCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeyCountryAggregateArgs = {
    /**
     * Filter which KeyCountry to aggregate.
     * 
    **/
    where?: KeyCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyCountries to fetch.
     * 
    **/
    orderBy?: Enumerable<KeyCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: KeyCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyCountries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyCountries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyCountries
    **/
    _count?: true | KeyCountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyCountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyCountryMaxAggregateInputType
  }

  export type GetKeyCountryAggregateType<T extends KeyCountryAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyCountry[P]>
      : GetScalarType<T[P], AggregateKeyCountry[P]>
  }




  export type KeyCountryGroupByArgs = {
    where?: KeyCountryWhereInput
    orderBy?: Enumerable<KeyCountryOrderByWithAggregationInput>
    by: Array<KeyCountryScalarFieldEnum>
    having?: KeyCountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyCountryCountAggregateInputType | true
    _min?: KeyCountryMinAggregateInputType
    _max?: KeyCountryMaxAggregateInputType
  }


  export type KeyCountryGroupByOutputType = {
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: KeyCountryCountAggregateOutputType | null
    _min: KeyCountryMinAggregateOutputType | null
    _max: KeyCountryMaxAggregateOutputType | null
  }

  type GetKeyCountryGroupByPayload<T extends KeyCountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<KeyCountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyCountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyCountryGroupByOutputType[P]>
            : GetScalarType<T[P], KeyCountryGroupByOutputType[P]>
        }
      >
    >


  export type KeyCountrySelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | KeyCountryCountOutputTypeArgs
  }

  export type KeyCountryInclude = {
    typeItems?: boolean | ItemFindManyArgs
    _count?: boolean | KeyCountryCountOutputTypeArgs
  }

  export type KeyCountryGetPayload<
    S extends boolean | null | undefined | KeyCountryArgs,
    U = keyof S
      > = S extends true
        ? KeyCountry
    : S extends undefined
    ? never
    : S extends KeyCountryArgs | KeyCountryFindManyArgs
    ?'include' extends U
    ? KeyCountry  & {
    [P in TrueKeys<S['include']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? KeyCountryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'typeItems' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? KeyCountryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KeyCountry ? KeyCountry[P] : never
  } 
    : KeyCountry
  : KeyCountry


  type KeyCountryCountArgs = Merge<
    Omit<KeyCountryFindManyArgs, 'select' | 'include'> & {
      select?: KeyCountryCountAggregateInputType | true
    }
  >

  export interface KeyCountryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one KeyCountry that matches the filter.
     * @param {KeyCountryFindUniqueArgs} args - Arguments to find a KeyCountry
     * @example
     * // Get one KeyCountry
     * const keyCountry = await prisma.keyCountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KeyCountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KeyCountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KeyCountry'> extends True ? CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>> : CheckSelect<T, Prisma__KeyCountryClient<KeyCountry | null >, Prisma__KeyCountryClient<KeyCountryGetPayload<T> | null >>

    /**
     * Find the first KeyCountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryFindFirstArgs} args - Arguments to find a KeyCountry
     * @example
     * // Get one KeyCountry
     * const keyCountry = await prisma.keyCountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KeyCountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KeyCountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KeyCountry'> extends True ? CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>> : CheckSelect<T, Prisma__KeyCountryClient<KeyCountry | null >, Prisma__KeyCountryClient<KeyCountryGetPayload<T> | null >>

    /**
     * Find zero or more KeyCountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyCountries
     * const keyCountries = await prisma.keyCountry.findMany()
     * 
     * // Get first 10 KeyCountries
     * const keyCountries = await prisma.keyCountry.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const keyCountryWithCodeOnly = await prisma.keyCountry.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends KeyCountryFindManyArgs>(
      args?: SelectSubset<T, KeyCountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<KeyCountry>>, PrismaPromise<Array<KeyCountryGetPayload<T>>>>

    /**
     * Create a KeyCountry.
     * @param {KeyCountryCreateArgs} args - Arguments to create a KeyCountry.
     * @example
     * // Create one KeyCountry
     * const KeyCountry = await prisma.keyCountry.create({
     *   data: {
     *     // ... data to create a KeyCountry
     *   }
     * })
     * 
    **/
    create<T extends KeyCountryCreateArgs>(
      args: SelectSubset<T, KeyCountryCreateArgs>
    ): CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>>

    /**
     * Create many KeyCountries.
     *     @param {KeyCountryCreateManyArgs} args - Arguments to create many KeyCountries.
     *     @example
     *     // Create many KeyCountries
     *     const keyCountry = await prisma.keyCountry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KeyCountryCreateManyArgs>(
      args?: SelectSubset<T, KeyCountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a KeyCountry.
     * @param {KeyCountryDeleteArgs} args - Arguments to delete one KeyCountry.
     * @example
     * // Delete one KeyCountry
     * const KeyCountry = await prisma.keyCountry.delete({
     *   where: {
     *     // ... filter to delete one KeyCountry
     *   }
     * })
     * 
    **/
    delete<T extends KeyCountryDeleteArgs>(
      args: SelectSubset<T, KeyCountryDeleteArgs>
    ): CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>>

    /**
     * Update one KeyCountry.
     * @param {KeyCountryUpdateArgs} args - Arguments to update one KeyCountry.
     * @example
     * // Update one KeyCountry
     * const keyCountry = await prisma.keyCountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KeyCountryUpdateArgs>(
      args: SelectSubset<T, KeyCountryUpdateArgs>
    ): CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>>

    /**
     * Delete zero or more KeyCountries.
     * @param {KeyCountryDeleteManyArgs} args - Arguments to filter KeyCountries to delete.
     * @example
     * // Delete a few KeyCountries
     * const { count } = await prisma.keyCountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KeyCountryDeleteManyArgs>(
      args?: SelectSubset<T, KeyCountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyCountries
     * const keyCountry = await prisma.keyCountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KeyCountryUpdateManyArgs>(
      args: SelectSubset<T, KeyCountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one KeyCountry.
     * @param {KeyCountryUpsertArgs} args - Arguments to update or create a KeyCountry.
     * @example
     * // Update or create a KeyCountry
     * const keyCountry = await prisma.keyCountry.upsert({
     *   create: {
     *     // ... data to create a KeyCountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyCountry we want to update
     *   }
     * })
    **/
    upsert<T extends KeyCountryUpsertArgs>(
      args: SelectSubset<T, KeyCountryUpsertArgs>
    ): CheckSelect<T, Prisma__KeyCountryClient<KeyCountry>, Prisma__KeyCountryClient<KeyCountryGetPayload<T>>>

    /**
     * Count the number of KeyCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryCountArgs} args - Arguments to filter KeyCountries to count.
     * @example
     * // Count the number of KeyCountries
     * const count = await prisma.keyCountry.count({
     *   where: {
     *     // ... the filter for the KeyCountries we want to count
     *   }
     * })
    **/
    count<T extends KeyCountryCountArgs>(
      args?: Subset<T, KeyCountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyCountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyCountryAggregateArgs>(args: Subset<T, KeyCountryAggregateArgs>): PrismaPromise<GetKeyCountryAggregateType<T>>

    /**
     * Group by KeyCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyCountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyCountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyCountryGroupByArgs['orderBy'] }
        : { orderBy?: KeyCountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyCountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyCountryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyCountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KeyCountryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    typeItems<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * KeyCountry findUnique
   */
  export type KeyCountryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * Throw an Error if a KeyCountry can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which KeyCountry to fetch.
     * 
    **/
    where: KeyCountryWhereUniqueInput
  }


  /**
   * KeyCountry findFirst
   */
  export type KeyCountryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * Throw an Error if a KeyCountry can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which KeyCountry to fetch.
     * 
    **/
    where?: KeyCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyCountries to fetch.
     * 
    **/
    orderBy?: Enumerable<KeyCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyCountries.
     * 
    **/
    cursor?: KeyCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyCountries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyCountries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyCountries.
     * 
    **/
    distinct?: Enumerable<KeyCountryScalarFieldEnum>
  }


  /**
   * KeyCountry findMany
   */
  export type KeyCountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * Filter, which KeyCountries to fetch.
     * 
    **/
    where?: KeyCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyCountries to fetch.
     * 
    **/
    orderBy?: Enumerable<KeyCountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyCountries.
     * 
    **/
    cursor?: KeyCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyCountries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyCountries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<KeyCountryScalarFieldEnum>
  }


  /**
   * KeyCountry create
   */
  export type KeyCountryCreateArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * The data needed to create a KeyCountry.
     * 
    **/
    data: XOR<KeyCountryCreateInput, KeyCountryUncheckedCreateInput>
  }


  /**
   * KeyCountry createMany
   */
  export type KeyCountryCreateManyArgs = {
    /**
     * The data used to create many KeyCountries.
     * 
    **/
    data: Enumerable<KeyCountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KeyCountry update
   */
  export type KeyCountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * The data needed to update a KeyCountry.
     * 
    **/
    data: XOR<KeyCountryUpdateInput, KeyCountryUncheckedUpdateInput>
    /**
     * Choose, which KeyCountry to update.
     * 
    **/
    where: KeyCountryWhereUniqueInput
  }


  /**
   * KeyCountry updateMany
   */
  export type KeyCountryUpdateManyArgs = {
    /**
     * The data used to update KeyCountries.
     * 
    **/
    data: XOR<KeyCountryUpdateManyMutationInput, KeyCountryUncheckedUpdateManyInput>
    /**
     * Filter which KeyCountries to update
     * 
    **/
    where?: KeyCountryWhereInput
  }


  /**
   * KeyCountry upsert
   */
  export type KeyCountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * The filter to search for the KeyCountry to update in case it exists.
     * 
    **/
    where: KeyCountryWhereUniqueInput
    /**
     * In case the KeyCountry found by the `where` argument doesn't exist, create a new KeyCountry with this data.
     * 
    **/
    create: XOR<KeyCountryCreateInput, KeyCountryUncheckedCreateInput>
    /**
     * In case the KeyCountry was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<KeyCountryUpdateInput, KeyCountryUncheckedUpdateInput>
  }


  /**
   * KeyCountry delete
   */
  export type KeyCountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
    /**
     * Filter which KeyCountry to delete.
     * 
    **/
    where: KeyCountryWhereUniqueInput
  }


  /**
   * KeyCountry deleteMany
   */
  export type KeyCountryDeleteManyArgs = {
    /**
     * Filter which KeyCountries to delete
     * 
    **/
    where?: KeyCountryWhereInput
  }


  /**
   * KeyCountry without action
   */
  export type KeyCountryArgs = {
    /**
     * Select specific fields to fetch from the KeyCountry
     * 
    **/
    select?: KeyCountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: KeyCountryInclude | null
  }



  /**
   * Model Item
   */


  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    quantity: number | null
    priceUnit: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    quantity: number | null
    priceUnit: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    typeId: string | null
    ccId: string | null
    kcId: string | null
    purchaseId: number | null
    description: string | null
    quantity: number | null
    priceUnit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    typeId: string | null
    ccId: string | null
    kcId: string | null
    purchaseId: number | null
    description: string | null
    quantity: number | null
    priceUnit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    typeId: number
    ccId: number
    kcId: number
    purchaseId: number
    description: number
    quantity: number
    priceUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    purchaseId?: true
    quantity?: true
    priceUnit?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    purchaseId?: true
    quantity?: true
    priceUnit?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    typeId?: true
    ccId?: true
    kcId?: true
    purchaseId?: true
    description?: true
    quantity?: true
    priceUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    typeId?: true
    ccId?: true
    kcId?: true
    purchaseId?: true
    description?: true
    quantity?: true
    priceUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    typeId?: true
    ccId?: true
    kcId?: true
    purchaseId?: true
    description?: true
    quantity?: true
    priceUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs = {
    /**
     * Filter which Item to aggregate.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs = {
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithAggregationInput>
    by: Array<ItemScalarFieldEnum>
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }


  export type ItemGroupByOutputType = {
    id: number
    typeId: string
    ccId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect = {
    id?: boolean
    type?: boolean | TypeItemArgs
    typeId?: boolean
    cc?: boolean | CostCenterArgs
    ccId?: boolean
    kc?: boolean | KeyCountryArgs
    kcId?: boolean
    purchase?: boolean | PurchaseRequestArgs
    purchaseId?: boolean
    description?: boolean
    quantity?: boolean
    priceUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude = {
    type?: boolean | TypeItemArgs
    cc?: boolean | CostCenterArgs
    kc?: boolean | KeyCountryArgs
    purchase?: boolean | PurchaseRequestArgs
  }

  export type ItemGetPayload<
    S extends boolean | null | undefined | ItemArgs,
    U = keyof S
      > = S extends true
        ? Item
    : S extends undefined
    ? never
    : S extends ItemArgs | ItemFindManyArgs
    ?'include' extends U
    ? Item  & {
    [P in TrueKeys<S['include']>]:
        P extends 'type' ? TypeItemGetPayload<S['include'][P]> :
        P extends 'cc' ? CostCenterGetPayload<S['include'][P]> :
        P extends 'kc' ? KeyCountryGetPayload<S['include'][P]> :
        P extends 'purchase' ? PurchaseRequestGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'type' ? TypeItemGetPayload<S['select'][P]> :
        P extends 'cc' ? CostCenterGetPayload<S['select'][P]> :
        P extends 'kc' ? KeyCountryGetPayload<S['select'][P]> :
        P extends 'purchase' ? PurchaseRequestGetPayload<S['select'][P]> :  P extends keyof Item ? Item[P] : never
  } 
    : Item
  : Item


  type ItemCountArgs = Merge<
    Omit<ItemFindManyArgs, 'select' | 'include'> & {
      select?: ItemCountAggregateInputType | true
    }
  >

  export interface ItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null >, Prisma__ItemClient<ItemGetPayload<T> | null >>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null >, Prisma__ItemClient<ItemGetPayload<T> | null >>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs>(
      args?: SelectSubset<T, ItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs>(
      args: SelectSubset<T, ItemCreateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs>(
      args?: SelectSubset<T, ItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs>(
      args: SelectSubset<T, ItemDeleteArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs>(
      args: SelectSubset<T, ItemUpdateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs>(
      args?: SelectSubset<T, ItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs>(
      args: SelectSubset<T, ItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs>(
      args: SelectSubset<T, ItemUpsertArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    type<T extends TypeItemArgs = {}>(args?: Subset<T, TypeItemArgs>): CheckSelect<T, Prisma__TypeItemClient<TypeItem | null >, Prisma__TypeItemClient<TypeItemGetPayload<T> | null >>;

    cc<T extends CostCenterArgs = {}>(args?: Subset<T, CostCenterArgs>): CheckSelect<T, Prisma__CostCenterClient<CostCenter | null >, Prisma__CostCenterClient<CostCenterGetPayload<T> | null >>;

    kc<T extends KeyCountryArgs = {}>(args?: Subset<T, KeyCountryArgs>): CheckSelect<T, Prisma__KeyCountryClient<KeyCountry | null >, Prisma__KeyCountryClient<KeyCountryGetPayload<T> | null >>;

    purchase<T extends PurchaseRequestArgs = {}>(args?: Subset<T, PurchaseRequestArgs>): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest | null >, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Throw an Error if a Item can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Throw an Error if a Item can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     * 
    **/
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter, which Items to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item create
   */
  export type ItemCreateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to create a Item.
     * 
    **/
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs = {
    /**
     * The data used to create many Items.
     * 
    **/
    data: Enumerable<ItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to update a Item.
     * 
    **/
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs = {
    /**
     * The data used to update Items.
     * 
    **/
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     * 
    **/
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The filter to search for the Item to update in case it exists.
     * 
    **/
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     * 
    **/
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter which Item to delete.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs = {
    /**
     * Filter which Items to delete
     * 
    **/
    where?: ItemWhereInput
  }


  /**
   * Item without action
   */
  export type ItemArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseRequests?: boolean | PurchaseRequestFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    purchaseRequests?: boolean | PurchaseRequestFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'purchaseRequests' ? Array < PurchaseRequestGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'purchaseRequests' ? Array < PurchaseRequestGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    purchaseRequests<T extends PurchaseRequestFindManyArgs = {}>(args?: Subset<T, PurchaseRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PurchaseRequest>>, PrismaPromise<Array<PurchaseRequestGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Vendor
   */


  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    codeSap: string | null
    name: string | null
    fiscalTaxId: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    codeSap: string | null
    name: string | null
    fiscalTaxId: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    codeSap: number
    name: number
    fiscalTaxId: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    codeSap?: true
    name?: true
    fiscalTaxId?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    codeSap?: true
    name?: true
    fiscalTaxId?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    codeSap?: true
    name?: true
    fiscalTaxId?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs = {
    /**
     * Filter which Vendor to aggregate.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs = {
    where?: VendorWhereInput
    orderBy?: Enumerable<VendorOrderByWithAggregationInput>
    by: Array<VendorScalarFieldEnum>
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }


  export type VendorGroupByOutputType = {
    id: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect = {
    id?: boolean
    codeSap?: boolean
    name?: boolean
    fiscalTaxId?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseRequests?: boolean | PurchaseRequestFindManyArgs
    bankAccounts?: boolean | BankAccountFindManyArgs
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | VendorCountOutputTypeArgs
  }

  export type VendorInclude = {
    purchaseRequests?: boolean | PurchaseRequestFindManyArgs
    bankAccounts?: boolean | BankAccountFindManyArgs
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | VendorCountOutputTypeArgs
  }

  export type VendorGetPayload<
    S extends boolean | null | undefined | VendorArgs,
    U = keyof S
      > = S extends true
        ? Vendor
    : S extends undefined
    ? never
    : S extends VendorArgs | VendorFindManyArgs
    ?'include' extends U
    ? Vendor  & {
    [P in TrueKeys<S['include']>]:
        P extends 'purchaseRequests' ? Array < PurchaseRequestGetPayload<S['include'][P]>>  :
        P extends 'bankAccounts' ? Array < BankAccountGetPayload<S['include'][P]>>  :
        P extends 'addresses' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'purchaseRequests' ? Array < PurchaseRequestGetPayload<S['select'][P]>>  :
        P extends 'bankAccounts' ? Array < BankAccountGetPayload<S['select'][P]>>  :
        P extends 'addresses' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Vendor ? Vendor[P] : never
  } 
    : Vendor
  : Vendor


  type VendorCountArgs = Merge<
    Omit<VendorFindManyArgs, 'select' | 'include'> & {
      select?: VendorCountAggregateInputType | true
    }
  >

  export interface VendorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor'> extends True ? CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>> : CheckSelect<T, Prisma__VendorClient<Vendor | null >, Prisma__VendorClient<VendorGetPayload<T> | null >>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor'> extends True ? CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>> : CheckSelect<T, Prisma__VendorClient<Vendor | null >, Prisma__VendorClient<VendorGetPayload<T> | null >>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorFindManyArgs>(
      args?: SelectSubset<T, VendorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendor>>, PrismaPromise<Array<VendorGetPayload<T>>>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
    **/
    create<T extends VendorCreateArgs>(
      args: SelectSubset<T, VendorCreateArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Create many Vendors.
     *     @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendor = await prisma.vendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorCreateManyArgs>(
      args?: SelectSubset<T, VendorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
    **/
    delete<T extends VendorDeleteArgs>(
      args: SelectSubset<T, VendorDeleteArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorUpdateArgs>(
      args: SelectSubset<T, VendorUpdateArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorDeleteManyArgs>(
      args?: SelectSubset<T, VendorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorUpdateManyArgs>(
      args: SelectSubset<T, VendorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
    **/
    upsert<T extends VendorUpsertArgs>(
      args: SelectSubset<T, VendorUpsertArgs>
    ): CheckSelect<T, Prisma__VendorClient<Vendor>, Prisma__VendorClient<VendorGetPayload<T>>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    purchaseRequests<T extends PurchaseRequestFindManyArgs = {}>(args?: Subset<T, PurchaseRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PurchaseRequest>>, PrismaPromise<Array<PurchaseRequestGetPayload<T>>>>;

    bankAccounts<T extends BankAccountFindManyArgs = {}>(args?: Subset<T, BankAccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BankAccount>>, PrismaPromise<Array<BankAccountGetPayload<T>>>>;

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Throw an Error if a Vendor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor to fetch.
     * 
    **/
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Throw an Error if a Vendor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor to fetch.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     * 
    **/
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter, which Vendors to fetch.
     * 
    **/
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     * 
    **/
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor create
   */
  export type VendorCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The data needed to create a Vendor.
     * 
    **/
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }


  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs = {
    /**
     * The data used to create many Vendors.
     * 
    **/
    data: Enumerable<VendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor update
   */
  export type VendorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The data needed to update a Vendor.
     * 
    **/
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     * 
    **/
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs = {
    /**
     * The data used to update Vendors.
     * 
    **/
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     * 
    **/
    where?: VendorWhereInput
  }


  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     * 
    **/
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     * 
    **/
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }


  /**
   * Vendor delete
   */
  export type VendorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
    /**
     * Filter which Vendor to delete.
     * 
    **/
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs = {
    /**
     * Filter which Vendors to delete
     * 
    **/
    where?: VendorWhereInput
  }


  /**
   * Vendor without action
   */
  export type VendorArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     * 
    **/
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorInclude | null
  }



  /**
   * Model PurchaseRequest
   */


  export type AggregatePurchaseRequest = {
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  export type PurchaseRequestAvgAggregateOutputType = {
    id: number | null
    requesterId: number | null
    totalContract: number | null
    vendorId: number | null
  }

  export type PurchaseRequestSumAggregateOutputType = {
    id: number | null
    requesterId: number | null
    totalContract: number | null
    vendorId: number | null
  }

  export type PurchaseRequestMinAggregateOutputType = {
    id: number | null
    requesterId: number | null
    type: RequestType | null
    delivery: Condition | null
    description: string | null
    totalContract: number | null
    startContract: Date | null
    endContract: Date | null
    contract: string | null
    vendorId: number | null
    observation: string | null
    status: PurchaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseRequestMaxAggregateOutputType = {
    id: number | null
    requesterId: number | null
    type: RequestType | null
    delivery: Condition | null
    description: string | null
    totalContract: number | null
    startContract: Date | null
    endContract: Date | null
    contract: string | null
    vendorId: number | null
    observation: string | null
    status: PurchaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseRequestCountAggregateOutputType = {
    id: number
    requesterId: number
    type: number
    delivery: number
    description: number
    totalContract: number
    startContract: number
    endContract: number
    contract: number
    vendorId: number
    observation: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseRequestAvgAggregateInputType = {
    id?: true
    requesterId?: true
    totalContract?: true
    vendorId?: true
  }

  export type PurchaseRequestSumAggregateInputType = {
    id?: true
    requesterId?: true
    totalContract?: true
    vendorId?: true
  }

  export type PurchaseRequestMinAggregateInputType = {
    id?: true
    requesterId?: true
    type?: true
    delivery?: true
    description?: true
    totalContract?: true
    startContract?: true
    endContract?: true
    contract?: true
    vendorId?: true
    observation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseRequestMaxAggregateInputType = {
    id?: true
    requesterId?: true
    type?: true
    delivery?: true
    description?: true
    totalContract?: true
    startContract?: true
    endContract?: true
    contract?: true
    vendorId?: true
    observation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseRequestCountAggregateInputType = {
    id?: true
    requesterId?: true
    type?: true
    delivery?: true
    description?: true
    totalContract?: true
    startContract?: true
    endContract?: true
    contract?: true
    vendorId?: true
    observation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseRequestAggregateArgs = {
    /**
     * Filter which PurchaseRequest to aggregate.
     * 
    **/
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchaseRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseRequests
    **/
    _count?: true | PurchaseRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type GetPurchaseRequestAggregateType<T extends PurchaseRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseRequest[P]>
      : GetScalarType<T[P], AggregatePurchaseRequest[P]>
  }




  export type PurchaseRequestGroupByArgs = {
    where?: PurchaseRequestWhereInput
    orderBy?: Enumerable<PurchaseRequestOrderByWithAggregationInput>
    by: Array<PurchaseRequestScalarFieldEnum>
    having?: PurchaseRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseRequestCountAggregateInputType | true
    _avg?: PurchaseRequestAvgAggregateInputType
    _sum?: PurchaseRequestSumAggregateInputType
    _min?: PurchaseRequestMinAggregateInputType
    _max?: PurchaseRequestMaxAggregateInputType
  }


  export type PurchaseRequestGroupByOutputType = {
    id: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date
    endContract: Date
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt: Date
    updatedAt: Date
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  type GetPurchaseRequestGroupByPayload<T extends PurchaseRequestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PurchaseRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseRequestSelect = {
    id?: boolean
    requester?: boolean | UserArgs
    requesterId?: boolean
    type?: boolean
    delivery?: boolean
    description?: boolean
    totalContract?: boolean
    startContract?: boolean
    endContract?: boolean
    contract?: boolean
    vendor?: boolean | VendorArgs
    vendorId?: boolean
    observation?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeItems?: boolean | ItemFindManyArgs
    approvals?: boolean | ApprovalFindManyArgs
    _count?: boolean | PurchaseRequestCountOutputTypeArgs
  }

  export type PurchaseRequestInclude = {
    requester?: boolean | UserArgs
    vendor?: boolean | VendorArgs
    typeItems?: boolean | ItemFindManyArgs
    approvals?: boolean | ApprovalFindManyArgs
    _count?: boolean | PurchaseRequestCountOutputTypeArgs
  }

  export type PurchaseRequestGetPayload<
    S extends boolean | null | undefined | PurchaseRequestArgs,
    U = keyof S
      > = S extends true
        ? PurchaseRequest
    : S extends undefined
    ? never
    : S extends PurchaseRequestArgs | PurchaseRequestFindManyArgs
    ?'include' extends U
    ? PurchaseRequest  & {
    [P in TrueKeys<S['include']>]:
        P extends 'requester' ? UserGetPayload<S['include'][P]> :
        P extends 'vendor' ? VendorGetPayload<S['include'][P]> :
        P extends 'typeItems' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends 'approvals' ? Array < ApprovalGetPayload<S['include'][P]>>  :
        P extends '_count' ? PurchaseRequestCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'requester' ? UserGetPayload<S['select'][P]> :
        P extends 'vendor' ? VendorGetPayload<S['select'][P]> :
        P extends 'typeItems' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends 'approvals' ? Array < ApprovalGetPayload<S['select'][P]>>  :
        P extends '_count' ? PurchaseRequestCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PurchaseRequest ? PurchaseRequest[P] : never
  } 
    : PurchaseRequest
  : PurchaseRequest


  type PurchaseRequestCountArgs = Merge<
    Omit<PurchaseRequestFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseRequestCountAggregateInputType | true
    }
  >

  export interface PurchaseRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PurchaseRequest that matches the filter.
     * @param {PurchaseRequestFindUniqueArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchaseRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PurchaseRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PurchaseRequest'> extends True ? CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>> : CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest | null >, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T> | null >>

    /**
     * Find the first PurchaseRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchaseRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PurchaseRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PurchaseRequest'> extends True ? CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>> : CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest | null >, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T> | null >>

    /**
     * Find zero or more PurchaseRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany()
     * 
     * // Get first 10 PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseRequestWithIdOnly = await prisma.purchaseRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PurchaseRequestFindManyArgs>(
      args?: SelectSubset<T, PurchaseRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PurchaseRequest>>, PrismaPromise<Array<PurchaseRequestGetPayload<T>>>>

    /**
     * Create a PurchaseRequest.
     * @param {PurchaseRequestCreateArgs} args - Arguments to create a PurchaseRequest.
     * @example
     * // Create one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.create({
     *   data: {
     *     // ... data to create a PurchaseRequest
     *   }
     * })
     * 
    **/
    create<T extends PurchaseRequestCreateArgs>(
      args: SelectSubset<T, PurchaseRequestCreateArgs>
    ): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>>

    /**
     * Create many PurchaseRequests.
     *     @param {PurchaseRequestCreateManyArgs} args - Arguments to create many PurchaseRequests.
     *     @example
     *     // Create many PurchaseRequests
     *     const purchaseRequest = await prisma.purchaseRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PurchaseRequestCreateManyArgs>(
      args?: SelectSubset<T, PurchaseRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseRequest.
     * @param {PurchaseRequestDeleteArgs} args - Arguments to delete one PurchaseRequest.
     * @example
     * // Delete one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.delete({
     *   where: {
     *     // ... filter to delete one PurchaseRequest
     *   }
     * })
     * 
    **/
    delete<T extends PurchaseRequestDeleteArgs>(
      args: SelectSubset<T, PurchaseRequestDeleteArgs>
    ): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>>

    /**
     * Update one PurchaseRequest.
     * @param {PurchaseRequestUpdateArgs} args - Arguments to update one PurchaseRequest.
     * @example
     * // Update one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchaseRequestUpdateArgs>(
      args: SelectSubset<T, PurchaseRequestUpdateArgs>
    ): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>>

    /**
     * Delete zero or more PurchaseRequests.
     * @param {PurchaseRequestDeleteManyArgs} args - Arguments to filter PurchaseRequests to delete.
     * @example
     * // Delete a few PurchaseRequests
     * const { count } = await prisma.purchaseRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchaseRequestDeleteManyArgs>(
      args?: SelectSubset<T, PurchaseRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchaseRequestUpdateManyArgs>(
      args: SelectSubset<T, PurchaseRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseRequest.
     * @param {PurchaseRequestUpsertArgs} args - Arguments to update or create a PurchaseRequest.
     * @example
     * // Update or create a PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.upsert({
     *   create: {
     *     // ... data to create a PurchaseRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseRequest we want to update
     *   }
     * })
    **/
    upsert<T extends PurchaseRequestUpsertArgs>(
      args: SelectSubset<T, PurchaseRequestUpsertArgs>
    ): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest>, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T>>>

    /**
     * Count the number of PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestCountArgs} args - Arguments to filter PurchaseRequests to count.
     * @example
     * // Count the number of PurchaseRequests
     * const count = await prisma.purchaseRequest.count({
     *   where: {
     *     // ... the filter for the PurchaseRequests we want to count
     *   }
     * })
    **/
    count<T extends PurchaseRequestCountArgs>(
      args?: Subset<T, PurchaseRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseRequestAggregateArgs>(args: Subset<T, PurchaseRequestAggregateArgs>): PrismaPromise<GetPurchaseRequestAggregateType<T>>

    /**
     * Group by PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseRequestGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseRequestGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PurchaseRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    requester<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    vendor<T extends VendorArgs = {}>(args?: Subset<T, VendorArgs>): CheckSelect<T, Prisma__VendorClient<Vendor | null >, Prisma__VendorClient<VendorGetPayload<T> | null >>;

    typeItems<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    approvals<T extends ApprovalFindManyArgs = {}>(args?: Subset<T, ApprovalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Approval>>, PrismaPromise<Array<ApprovalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PurchaseRequest findUnique
   */
  export type PurchaseRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * Throw an Error if a PurchaseRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PurchaseRequest to fetch.
     * 
    **/
    where: PurchaseRequestWhereUniqueInput
  }


  /**
   * PurchaseRequest findFirst
   */
  export type PurchaseRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * Throw an Error if a PurchaseRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PurchaseRequest to fetch.
     * 
    **/
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchaseRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     * 
    **/
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     * 
    **/
    distinct?: Enumerable<PurchaseRequestScalarFieldEnum>
  }


  /**
   * PurchaseRequest findMany
   */
  export type PurchaseRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * Filter, which PurchaseRequests to fetch.
     * 
    **/
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<PurchaseRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseRequests.
     * 
    **/
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PurchaseRequestScalarFieldEnum>
  }


  /**
   * PurchaseRequest create
   */
  export type PurchaseRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * The data needed to create a PurchaseRequest.
     * 
    **/
    data: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
  }


  /**
   * PurchaseRequest createMany
   */
  export type PurchaseRequestCreateManyArgs = {
    /**
     * The data used to create many PurchaseRequests.
     * 
    **/
    data: Enumerable<PurchaseRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PurchaseRequest update
   */
  export type PurchaseRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * The data needed to update a PurchaseRequest.
     * 
    **/
    data: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
    /**
     * Choose, which PurchaseRequest to update.
     * 
    **/
    where: PurchaseRequestWhereUniqueInput
  }


  /**
   * PurchaseRequest updateMany
   */
  export type PurchaseRequestUpdateManyArgs = {
    /**
     * The data used to update PurchaseRequests.
     * 
    **/
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseRequests to update
     * 
    **/
    where?: PurchaseRequestWhereInput
  }


  /**
   * PurchaseRequest upsert
   */
  export type PurchaseRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * The filter to search for the PurchaseRequest to update in case it exists.
     * 
    **/
    where: PurchaseRequestWhereUniqueInput
    /**
     * In case the PurchaseRequest found by the `where` argument doesn't exist, create a new PurchaseRequest with this data.
     * 
    **/
    create: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
    /**
     * In case the PurchaseRequest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
  }


  /**
   * PurchaseRequest delete
   */
  export type PurchaseRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
    /**
     * Filter which PurchaseRequest to delete.
     * 
    **/
    where: PurchaseRequestWhereUniqueInput
  }


  /**
   * PurchaseRequest deleteMany
   */
  export type PurchaseRequestDeleteManyArgs = {
    /**
     * Filter which PurchaseRequests to delete
     * 
    **/
    where?: PurchaseRequestWhereInput
  }


  /**
   * PurchaseRequest without action
   */
  export type PurchaseRequestArgs = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     * 
    **/
    select?: PurchaseRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PurchaseRequestInclude | null
  }



  /**
   * Model Approval
   */


  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalAvgAggregateOutputType = {
    purchaseId: number | null
  }

  export type ApprovalSumAggregateOutputType = {
    purchaseId: number | null
  }

  export type ApprovalMinAggregateOutputType = {
    emailApprover: string | null
    status: boolean | null
    purchaseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    emailApprover: string | null
    status: boolean | null
    purchaseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    emailApprover: number
    status: number
    purchaseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalAvgAggregateInputType = {
    purchaseId?: true
  }

  export type ApprovalSumAggregateInputType = {
    purchaseId?: true
  }

  export type ApprovalMinAggregateInputType = {
    emailApprover?: true
    status?: true
    purchaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    emailApprover?: true
    status?: true
    purchaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    emailApprover?: true
    status?: true
    purchaseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs = {
    /**
     * Filter which Approval to aggregate.
     * 
    **/
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     * 
    **/
    orderBy?: Enumerable<ApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs = {
    where?: ApprovalWhereInput
    orderBy?: Enumerable<ApprovalOrderByWithAggregationInput>
    by: Array<ApprovalScalarFieldEnum>
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _avg?: ApprovalAvgAggregateInputType
    _sum?: ApprovalSumAggregateInputType
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }


  export type ApprovalGroupByOutputType = {
    emailApprover: string
    status: boolean
    purchaseId: number
    createdAt: Date
    updatedAt: Date
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect = {
    emailApprover?: boolean
    status?: boolean
    purchase?: boolean | PurchaseRequestArgs
    purchaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalInclude = {
    purchase?: boolean | PurchaseRequestArgs
  }

  export type ApprovalGetPayload<
    S extends boolean | null | undefined | ApprovalArgs,
    U = keyof S
      > = S extends true
        ? Approval
    : S extends undefined
    ? never
    : S extends ApprovalArgs | ApprovalFindManyArgs
    ?'include' extends U
    ? Approval  & {
    [P in TrueKeys<S['include']>]:
        P extends 'purchase' ? PurchaseRequestGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'purchase' ? PurchaseRequestGetPayload<S['select'][P]> :  P extends keyof Approval ? Approval[P] : never
  } 
    : Approval
  : Approval


  type ApprovalCountArgs = Merge<
    Omit<ApprovalFindManyArgs, 'select' | 'include'> & {
      select?: ApprovalCountAggregateInputType | true
    }
  >

  export interface ApprovalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApprovalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ApprovalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Approval'> extends True ? CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>> : CheckSelect<T, Prisma__ApprovalClient<Approval | null >, Prisma__ApprovalClient<ApprovalGetPayload<T> | null >>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApprovalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ApprovalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Approval'> extends True ? CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>> : CheckSelect<T, Prisma__ApprovalClient<Approval | null >, Prisma__ApprovalClient<ApprovalGetPayload<T> | null >>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `emailApprover`
     * const approvalWithEmailApproverOnly = await prisma.approval.findMany({ select: { emailApprover: true } })
     * 
    **/
    findMany<T extends ApprovalFindManyArgs>(
      args?: SelectSubset<T, ApprovalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Approval>>, PrismaPromise<Array<ApprovalGetPayload<T>>>>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
    **/
    create<T extends ApprovalCreateArgs>(
      args: SelectSubset<T, ApprovalCreateArgs>
    ): CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>>

    /**
     * Create many Approvals.
     *     @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     *     @example
     *     // Create many Approvals
     *     const approval = await prisma.approval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApprovalCreateManyArgs>(
      args?: SelectSubset<T, ApprovalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
    **/
    delete<T extends ApprovalDeleteArgs>(
      args: SelectSubset<T, ApprovalDeleteArgs>
    ): CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApprovalUpdateArgs>(
      args: SelectSubset<T, ApprovalUpdateArgs>
    ): CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApprovalDeleteManyArgs>(
      args?: SelectSubset<T, ApprovalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApprovalUpdateManyArgs>(
      args: SelectSubset<T, ApprovalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
    **/
    upsert<T extends ApprovalUpsertArgs>(
      args: SelectSubset<T, ApprovalUpsertArgs>
    ): CheckSelect<T, Prisma__ApprovalClient<Approval>, Prisma__ApprovalClient<ApprovalGetPayload<T>>>

    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ApprovalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    purchase<T extends PurchaseRequestArgs = {}>(args?: Subset<T, PurchaseRequestArgs>): CheckSelect<T, Prisma__PurchaseRequestClient<PurchaseRequest | null >, Prisma__PurchaseRequestClient<PurchaseRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * Throw an Error if a Approval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Approval to fetch.
     * 
    **/
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * Throw an Error if a Approval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Approval to fetch.
     * 
    **/
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     * 
    **/
    orderBy?: Enumerable<ApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     * 
    **/
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     * 
    **/
    distinct?: Enumerable<ApprovalScalarFieldEnum>
  }


  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * Filter, which Approvals to fetch.
     * 
    **/
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     * 
    **/
    orderBy?: Enumerable<ApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     * 
    **/
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ApprovalScalarFieldEnum>
  }


  /**
   * Approval create
   */
  export type ApprovalCreateArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * The data needed to create a Approval.
     * 
    **/
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }


  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs = {
    /**
     * The data used to create many Approvals.
     * 
    **/
    data: Enumerable<ApprovalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Approval update
   */
  export type ApprovalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * The data needed to update a Approval.
     * 
    **/
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     * 
    **/
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs = {
    /**
     * The data used to update Approvals.
     * 
    **/
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     * 
    **/
    where?: ApprovalWhereInput
  }


  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * The filter to search for the Approval to update in case it exists.
     * 
    **/
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     * 
    **/
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }


  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
    /**
     * Filter which Approval to delete.
     * 
    **/
    where: ApprovalWhereUniqueInput
  }


  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs = {
    /**
     * Filter which Approvals to delete
     * 
    **/
    where?: ApprovalWhereInput
  }


  /**
   * Approval without action
   */
  export type ApprovalArgs = {
    /**
     * Select specific fields to fetch from the Approval
     * 
    **/
    select?: ApprovalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApprovalInclude | null
  }



  /**
   * Model BankAccount
   */


  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    vendorId: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    vendorId: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    vendorId: number | null
    codeBank: string | null
    branch: string | null
    account: string | null
    digit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    vendorId: number | null
    codeBank: string | null
    branch: string | null
    account: string | null
    digit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    vendorId: number
    codeBank: number
    branch: number
    account: number
    digit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    vendorId?: true
  }

  export type BankAccountSumAggregateInputType = {
    vendorId?: true
  }

  export type BankAccountMinAggregateInputType = {
    vendorId?: true
    codeBank?: true
    branch?: true
    account?: true
    digit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    vendorId?: true
    codeBank?: true
    branch?: true
    account?: true
    digit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    vendorId?: true
    codeBank?: true
    branch?: true
    account?: true
    digit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs = {
    /**
     * Filter which BankAccount to aggregate.
     * 
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs = {
    where?: BankAccountWhereInput
    orderBy?: Enumerable<BankAccountOrderByWithAggregationInput>
    by: Array<BankAccountScalarFieldEnum>
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }


  export type BankAccountGroupByOutputType = {
    vendorId: number
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect = {
    vendor?: boolean | VendorArgs
    vendorId?: boolean
    codeBank?: boolean
    branch?: boolean
    account?: boolean
    digit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountInclude = {
    vendor?: boolean | VendorArgs
  }

  export type BankAccountGetPayload<
    S extends boolean | null | undefined | BankAccountArgs,
    U = keyof S
      > = S extends true
        ? BankAccount
    : S extends undefined
    ? never
    : S extends BankAccountArgs | BankAccountFindManyArgs
    ?'include' extends U
    ? BankAccount  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vendor' ? VendorGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vendor' ? VendorGetPayload<S['select'][P]> :  P extends keyof BankAccount ? BankAccount[P] : never
  } 
    : BankAccount
  : BankAccount


  type BankAccountCountArgs = Merge<
    Omit<BankAccountFindManyArgs, 'select' | 'include'> & {
      select?: BankAccountCountAggregateInputType | true
    }
  >

  export interface BankAccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankAccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankAccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BankAccount'> extends True ? CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>> : CheckSelect<T, Prisma__BankAccountClient<BankAccount | null >, Prisma__BankAccountClient<BankAccountGetPayload<T> | null >>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankAccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankAccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BankAccount'> extends True ? CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>> : CheckSelect<T, Prisma__BankAccountClient<BankAccount | null >, Prisma__BankAccountClient<BankAccountGetPayload<T> | null >>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `vendorId`
     * const bankAccountWithVendorIdOnly = await prisma.bankAccount.findMany({ select: { vendorId: true } })
     * 
    **/
    findMany<T extends BankAccountFindManyArgs>(
      args?: SelectSubset<T, BankAccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BankAccount>>, PrismaPromise<Array<BankAccountGetPayload<T>>>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
    **/
    create<T extends BankAccountCreateArgs>(
      args: SelectSubset<T, BankAccountCreateArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Create many BankAccounts.
     *     @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     *     @example
     *     // Create many BankAccounts
     *     const bankAccount = await prisma.bankAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankAccountCreateManyArgs>(
      args?: SelectSubset<T, BankAccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
    **/
    delete<T extends BankAccountDeleteArgs>(
      args: SelectSubset<T, BankAccountDeleteArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankAccountUpdateArgs>(
      args: SelectSubset<T, BankAccountUpdateArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankAccountDeleteManyArgs>(
      args?: SelectSubset<T, BankAccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankAccountUpdateManyArgs>(
      args: SelectSubset<T, BankAccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
    **/
    upsert<T extends BankAccountUpsertArgs>(
      args: SelectSubset<T, BankAccountUpsertArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankAccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vendor<T extends VendorArgs = {}>(args?: Subset<T, VendorArgs>): CheckSelect<T, Prisma__VendorClient<Vendor | null >, Prisma__VendorClient<VendorGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * Throw an Error if a BankAccount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BankAccount to fetch.
     * 
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * Throw an Error if a BankAccount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BankAccount to fetch.
     * 
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     * 
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     * 
    **/
    distinct?: Enumerable<BankAccountScalarFieldEnum>
  }


  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * Filter, which BankAccounts to fetch.
     * 
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     * 
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     * 
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BankAccountScalarFieldEnum>
  }


  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * The data needed to create a BankAccount.
     * 
    **/
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }


  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs = {
    /**
     * The data used to create many BankAccounts.
     * 
    **/
    data: Enumerable<BankAccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * The data needed to update a BankAccount.
     * 
    **/
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     * 
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs = {
    /**
     * The data used to update BankAccounts.
     * 
    **/
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     * 
    **/
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     * 
    **/
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     * 
    **/
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }


  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
    /**
     * Filter which BankAccount to delete.
     * 
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs = {
    /**
     * Filter which BankAccounts to delete
     * 
    **/
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount without action
   */
  export type BankAccountArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     * 
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BankAccountInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    code: number | null
  }

  export type CitySumAggregateOutputType = {
    code: number | null
  }

  export type CityMinAggregateOutputType = {
    code: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    code: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    code?: true
  }

  export type CitySumAggregateInputType = {
    code?: true
  }

  export type CityMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    code: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityInclude = {
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof City ? City[P] : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const cityWithCodeOnly = await prisma.city.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     * 
    **/
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     * 
    **/
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateMaxAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StateCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StateCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: Array<StateScalarFieldEnum>
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateInclude = {
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateGetPayload<
    S extends boolean | null | undefined | StateArgs,
    U = keyof S
      > = S extends true
        ? State
    : S extends undefined
    ? never
    : S extends StateArgs | StateFindManyArgs
    ?'include' extends U
    ? State  & {
    [P in TrueKeys<S['include']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof State ? State[P] : never
  } 
    : State
  : State


  type StateCountArgs = Merge<
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }
  >

  export interface StateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const stateWithCodeOnly = await prisma.state.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * State findUnique
   */
  export type StateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Throw an Error if a State can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which State to fetch.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State findFirst
   */
  export type StateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Throw an Error if a State can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which State to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     * 
    **/
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to create a State.
     * 
    **/
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    /**
     * The data used to create many States.
     * 
    **/
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to update a State.
     * 
    **/
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    /**
     * The data used to update States.
     * 
    **/
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
     * 
    **/
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     * 
    **/
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter which State to delete.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    /**
     * Filter which States to delete
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryInclude = {
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'addresses' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Country ? Country[P] : never
  } 
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const countryWithCodeOnly = await prisma.country.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     * 
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     * 
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    /**
     * The data used to create many Countries.
     * 
    **/
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     * 
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    /**
     * The data used to update Countries.
     * 
    **/
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     * 
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     * 
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    /**
     * Filter which Countries to delete
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    vendorId: number | null
    streetNo: number | null
    cityId: number | null
  }

  export type AddressSumAggregateOutputType = {
    vendorId: number | null
    streetNo: number | null
    cityId: number | null
  }

  export type AddressMinAggregateOutputType = {
    vendorId: number | null
    addressType: string | null
    street: string | null
    streetNo: number | null
    complement: string | null
    zipCode: string | null
    block: string | null
    cityId: number | null
    stateId: string | null
    countryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    vendorId: number | null
    addressType: string | null
    street: string | null
    streetNo: number | null
    complement: string | null
    zipCode: string | null
    block: string | null
    cityId: number | null
    stateId: string | null
    countryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    vendorId: number
    addressType: number
    street: number
    streetNo: number
    complement: number
    zipCode: number
    block: number
    cityId: number
    stateId: number
    countryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    vendorId?: true
    streetNo?: true
    cityId?: true
  }

  export type AddressSumAggregateInputType = {
    vendorId?: true
    streetNo?: true
    cityId?: true
  }

  export type AddressMinAggregateInputType = {
    vendorId?: true
    addressType?: true
    street?: true
    streetNo?: true
    complement?: true
    zipCode?: true
    block?: true
    cityId?: true
    stateId?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    vendorId?: true
    addressType?: true
    street?: true
    streetNo?: true
    complement?: true
    zipCode?: true
    block?: true
    cityId?: true
    stateId?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    vendorId?: true
    addressType?: true
    street?: true
    streetNo?: true
    complement?: true
    zipCode?: true
    block?: true
    cityId?: true
    stateId?: true
    countryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    countryId: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    vendor?: boolean | VendorArgs
    vendorId?: boolean
    addressType?: boolean
    street?: boolean
    streetNo?: boolean
    complement?: boolean
    zipCode?: boolean
    block?: boolean
    city?: boolean | CityArgs
    cityId?: boolean
    state?: boolean | StateArgs
    stateId?: boolean
    country?: boolean | CountryArgs
    countryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressInclude = {
    vendor?: boolean | VendorArgs
    city?: boolean | CityArgs
    state?: boolean | StateArgs
    country?: boolean | CountryArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vendor' ? VendorGetPayload<S['include'][P]> :
        P extends 'city' ? CityGetPayload<S['include'][P]> :
        P extends 'state' ? StateGetPayload<S['include'][P]> :
        P extends 'country' ? CountryGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vendor' ? VendorGetPayload<S['select'][P]> :
        P extends 'city' ? CityGetPayload<S['select'][P]> :
        P extends 'state' ? StateGetPayload<S['select'][P]> :
        P extends 'country' ? CountryGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `vendorId`
     * const addressWithVendorIdOnly = await prisma.address.findMany({ select: { vendorId: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vendor<T extends VendorArgs = {}>(args?: Subset<T, VendorArgs>): CheckSelect<T, Prisma__VendorClient<Vendor | null >, Prisma__VendorClient<VendorGetPayload<T> | null >>;

    city<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>;

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>;

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const TypeItemScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeItemScalarFieldEnum = (typeof TypeItemScalarFieldEnum)[keyof typeof TypeItemScalarFieldEnum]


  export const CostCenterScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


  export const KeyCountryScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeyCountryScalarFieldEnum = (typeof KeyCountryScalarFieldEnum)[keyof typeof KeyCountryScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    ccId: 'ccId',
    kcId: 'kcId',
    purchaseId: 'purchaseId',
    description: 'description',
    quantity: 'quantity',
    priceUnit: 'priceUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    codeSap: 'codeSap',
    name: 'name',
    fiscalTaxId: 'fiscalTaxId',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const PurchaseRequestScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    type: 'type',
    delivery: 'delivery',
    description: 'description',
    totalContract: 'totalContract',
    startContract: 'startContract',
    endContract: 'endContract',
    contract: 'contract',
    vendorId: 'vendorId',
    observation: 'observation',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseRequestScalarFieldEnum = (typeof PurchaseRequestScalarFieldEnum)[keyof typeof PurchaseRequestScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    emailApprover: 'emailApprover',
    status: 'status',
    purchaseId: 'purchaseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    vendorId: 'vendorId',
    codeBank: 'codeBank',
    branch: 'branch',
    account: 'account',
    digit: 'digit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const CityScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const StateScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    vendorId: 'vendorId',
    addressType: 'addressType',
    street: 'street',
    streetNo: 'streetNo',
    complement: 'complement',
    zipCode: 'zipCode',
    block: 'block',
    cityId: 'cityId',
    stateId: 'stateId',
    countryId: 'countryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type TypeItemWhereInput = {
    AND?: Enumerable<TypeItemWhereInput>
    OR?: Enumerable<TypeItemWhereInput>
    NOT?: Enumerable<TypeItemWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    typeItems?: ItemListRelationFilter
  }

  export type TypeItemOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeItems?: ItemOrderByRelationAggregateInput
  }

  export type TypeItemWhereUniqueInput = {
    code?: string
  }

  export type TypeItemOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeItemCountOrderByAggregateInput
    _max?: TypeItemMaxOrderByAggregateInput
    _min?: TypeItemMinOrderByAggregateInput
  }

  export type TypeItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypeItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypeItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypeItemScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CostCenterWhereInput = {
    AND?: Enumerable<CostCenterWhereInput>
    OR?: Enumerable<CostCenterWhereInput>
    NOT?: Enumerable<CostCenterWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    typeItems?: ItemListRelationFilter
  }

  export type CostCenterOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeItems?: ItemOrderByRelationAggregateInput
  }

  export type CostCenterWhereUniqueInput = {
    code?: string
  }

  export type CostCenterOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostCenterCountOrderByAggregateInput
    _max?: CostCenterMaxOrderByAggregateInput
    _min?: CostCenterMinOrderByAggregateInput
  }

  export type CostCenterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CostCenterScalarWhereWithAggregatesInput>
    OR?: Enumerable<CostCenterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CostCenterScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KeyCountryWhereInput = {
    AND?: Enumerable<KeyCountryWhereInput>
    OR?: Enumerable<KeyCountryWhereInput>
    NOT?: Enumerable<KeyCountryWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    typeItems?: ItemListRelationFilter
  }

  export type KeyCountryOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeItems?: ItemOrderByRelationAggregateInput
  }

  export type KeyCountryWhereUniqueInput = {
    code?: string
  }

  export type KeyCountryOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeyCountryCountOrderByAggregateInput
    _max?: KeyCountryMaxOrderByAggregateInput
    _min?: KeyCountryMinOrderByAggregateInput
  }

  export type KeyCountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KeyCountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<KeyCountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KeyCountryScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemWhereInput = {
    AND?: Enumerable<ItemWhereInput>
    OR?: Enumerable<ItemWhereInput>
    NOT?: Enumerable<ItemWhereInput>
    id?: IntFilter | number
    type?: XOR<TypeItemRelationFilter, TypeItemWhereInput>
    typeId?: StringFilter | string
    cc?: XOR<CostCenterRelationFilter, CostCenterWhereInput>
    ccId?: StringFilter | string
    kc?: XOR<KeyCountryRelationFilter, KeyCountryWhereInput>
    kcId?: StringFilter | string
    purchase?: XOR<PurchaseRequestRelationFilter, PurchaseRequestWhereInput>
    purchaseId?: IntFilter | number
    description?: StringFilter | string
    quantity?: IntFilter | number
    priceUnit?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: TypeItemOrderByWithRelationInput
    typeId?: SortOrder
    cc?: CostCenterOrderByWithRelationInput
    ccId?: SortOrder
    kc?: KeyCountryOrderByWithRelationInput
    kcId?: SortOrder
    purchase?: PurchaseRequestOrderByWithRelationInput
    purchaseId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemWhereUniqueInput = {
    id?: number
  }

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    typeId?: SortOrder
    ccId?: SortOrder
    kcId?: SortOrder
    purchaseId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    typeId?: StringWithAggregatesFilter | string
    ccId?: StringWithAggregatesFilter | string
    kcId?: StringWithAggregatesFilter | string
    purchaseId?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    priceUnit?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseRequests?: PurchaseRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VendorWhereInput = {
    AND?: Enumerable<VendorWhereInput>
    OR?: Enumerable<VendorWhereInput>
    NOT?: Enumerable<VendorWhereInput>
    id?: IntFilter | number
    codeSap?: StringFilter | string
    name?: StringFilter | string
    fiscalTaxId?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseRequests?: PurchaseRequestListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
    addresses?: AddressListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    codeSap?: SortOrder
    name?: SortOrder
    fiscalTaxId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseRequests?: PurchaseRequestOrderByRelationAggregateInput
    bankAccounts?: BankAccountOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = {
    id?: number
    codeSap?: string
    name?: string
    fiscalTaxId?: string
    email?: string
  }

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    codeSap?: SortOrder
    name?: SortOrder
    fiscalTaxId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    codeSap?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    fiscalTaxId?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PurchaseRequestWhereInput = {
    AND?: Enumerable<PurchaseRequestWhereInput>
    OR?: Enumerable<PurchaseRequestWhereInput>
    NOT?: Enumerable<PurchaseRequestWhereInput>
    id?: IntFilter | number
    requester?: XOR<UserRelationFilter, UserWhereInput>
    requesterId?: IntFilter | number
    type?: EnumRequestTypeFilter | RequestType
    delivery?: EnumConditionFilter | Condition
    description?: StringFilter | string
    totalContract?: IntFilter | number
    startContract?: DateTimeFilter | Date | string
    endContract?: DateTimeFilter | Date | string
    contract?: StringFilter | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    vendorId?: IntFilter | number
    observation?: StringFilter | string
    status?: EnumPurchaseStatusFilter | PurchaseStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    typeItems?: ItemListRelationFilter
    approvals?: ApprovalListRelationFilter
  }

  export type PurchaseRequestOrderByWithRelationInput = {
    id?: SortOrder
    requester?: UserOrderByWithRelationInput
    requesterId?: SortOrder
    type?: SortOrder
    delivery?: SortOrder
    description?: SortOrder
    totalContract?: SortOrder
    startContract?: SortOrder
    endContract?: SortOrder
    contract?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    vendorId?: SortOrder
    observation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeItems?: ItemOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
  }

  export type PurchaseRequestWhereUniqueInput = {
    id?: number
  }

  export type PurchaseRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    type?: SortOrder
    delivery?: SortOrder
    description?: SortOrder
    totalContract?: SortOrder
    startContract?: SortOrder
    endContract?: SortOrder
    contract?: SortOrder
    vendorId?: SortOrder
    observation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseRequestCountOrderByAggregateInput
    _avg?: PurchaseRequestAvgOrderByAggregateInput
    _max?: PurchaseRequestMaxOrderByAggregateInput
    _min?: PurchaseRequestMinOrderByAggregateInput
    _sum?: PurchaseRequestSumOrderByAggregateInput
  }

  export type PurchaseRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PurchaseRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<PurchaseRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PurchaseRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    requesterId?: IntWithAggregatesFilter | number
    type?: EnumRequestTypeWithAggregatesFilter | RequestType
    delivery?: EnumConditionWithAggregatesFilter | Condition
    description?: StringWithAggregatesFilter | string
    totalContract?: IntWithAggregatesFilter | number
    startContract?: DateTimeWithAggregatesFilter | Date | string
    endContract?: DateTimeWithAggregatesFilter | Date | string
    contract?: StringWithAggregatesFilter | string
    vendorId?: IntWithAggregatesFilter | number
    observation?: StringWithAggregatesFilter | string
    status?: EnumPurchaseStatusWithAggregatesFilter | PurchaseStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ApprovalWhereInput = {
    AND?: Enumerable<ApprovalWhereInput>
    OR?: Enumerable<ApprovalWhereInput>
    NOT?: Enumerable<ApprovalWhereInput>
    emailApprover?: StringFilter | string
    status?: BoolFilter | boolean
    purchase?: XOR<PurchaseRequestRelationFilter, PurchaseRequestWhereInput>
    purchaseId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ApprovalOrderByWithRelationInput = {
    emailApprover?: SortOrder
    status?: SortOrder
    purchase?: PurchaseRequestOrderByWithRelationInput
    purchaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWhereUniqueInput = {
    emailApprover_purchaseId?: ApprovalEmailApproverPurchaseIdCompoundUniqueInput
  }

  export type ApprovalOrderByWithAggregationInput = {
    emailApprover?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _avg?: ApprovalAvgOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
    _sum?: ApprovalSumOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ApprovalScalarWhereWithAggregatesInput>
    OR?: Enumerable<ApprovalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ApprovalScalarWhereWithAggregatesInput>
    emailApprover?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    purchaseId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: Enumerable<BankAccountWhereInput>
    OR?: Enumerable<BankAccountWhereInput>
    NOT?: Enumerable<BankAccountWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    vendorId?: IntFilter | number
    codeBank?: StringFilter | string
    branch?: StringFilter | string
    account?: StringFilter | string
    digit?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BankAccountOrderByWithRelationInput = {
    vendor?: VendorOrderByWithRelationInput
    vendorId?: SortOrder
    codeBank?: SortOrder
    branch?: SortOrder
    account?: SortOrder
    digit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountWhereUniqueInput = {
    vendorId?: number
  }

  export type BankAccountOrderByWithAggregationInput = {
    vendorId?: SortOrder
    codeBank?: SortOrder
    branch?: SortOrder
    account?: SortOrder
    digit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    vendorId?: IntWithAggregatesFilter | number
    codeBank?: StringWithAggregatesFilter | string
    branch?: StringWithAggregatesFilter | string
    account?: StringWithAggregatesFilter | string
    digit?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    code?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    addresses?: AddressListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    code?: number
  }

  export type CityOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    code?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    addresses?: AddressListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = {
    code?: string
  }

  export type StateOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    addresses?: AddressListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = {
    code?: string
  }

  export type CountryOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    vendorId?: IntFilter | number
    addressType?: StringFilter | string
    street?: StringFilter | string
    streetNo?: IntFilter | number
    complement?: StringFilter | string
    zipCode?: StringFilter | string
    block?: StringFilter | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    cityId?: IntFilter | number
    state?: XOR<StateRelationFilter, StateWhereInput>
    stateId?: StringFilter | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    countryId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AddressOrderByWithRelationInput = {
    vendor?: VendorOrderByWithRelationInput
    vendorId?: SortOrder
    addressType?: SortOrder
    street?: SortOrder
    streetNo?: SortOrder
    complement?: SortOrder
    zipCode?: SortOrder
    block?: SortOrder
    city?: CityOrderByWithRelationInput
    cityId?: SortOrder
    state?: StateOrderByWithRelationInput
    stateId?: SortOrder
    country?: CountryOrderByWithRelationInput
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    vendorId?: number
  }

  export type AddressOrderByWithAggregationInput = {
    vendorId?: SortOrder
    addressType?: SortOrder
    street?: SortOrder
    streetNo?: SortOrder
    complement?: SortOrder
    zipCode?: SortOrder
    block?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    vendorId?: IntWithAggregatesFilter | number
    addressType?: StringWithAggregatesFilter | string
    street?: StringWithAggregatesFilter | string
    streetNo?: IntWithAggregatesFilter | number
    complement?: StringWithAggregatesFilter | string
    zipCode?: StringWithAggregatesFilter | string
    block?: StringWithAggregatesFilter | string
    cityId?: IntWithAggregatesFilter | number
    stateId?: StringWithAggregatesFilter | string
    countryId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TypeItemCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutTypeInput
  }

  export type TypeItemUncheckedCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeItemUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutTypeInput
  }

  export type TypeItemUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutTypeInput
  }

  export type TypeItemCreateManyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeItemUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeItemUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutCcInput
  }

  export type CostCenterUncheckedCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutCcInput
  }

  export type CostCenterUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutCcInput
  }

  export type CostCenterUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutCcInput
  }

  export type CostCenterCreateManyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyCountryCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutKcInput
  }

  export type KeyCountryUncheckedCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutKcInput
  }

  export type KeyCountryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutKcInput
  }

  export type KeyCountryUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutKcInput
  }

  export type KeyCountryCreateManyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyCountryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyCountryUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    type: TypeItemCreateNestedOneWithoutTypeItemsInput
    cc: CostCenterCreateNestedOneWithoutTypeItemsInput
    kc: KeyCountryCreateNestedOneWithoutTypeItemsInput
    purchase: PurchaseRequestCreateNestedOneWithoutTypeItemsInput
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    typeId: string
    ccId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateInput = {
    type?: TypeItemUpdateOneRequiredWithoutTypeItemsInput
    cc?: CostCenterUpdateOneRequiredWithoutTypeItemsInput
    kc?: KeyCountryUpdateOneRequiredWithoutTypeItemsInput
    purchase?: PurchaseRequestUpdateOneRequiredWithoutTypeItemsInput
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: StringFieldUpdateOperationsInput | string
    ccId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyInput = {
    id?: number
    typeId: string
    ccId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: StringFieldUpdateOperationsInput | string
    ccId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUpdateManyWithoutRequesterInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutVendorInput
    bankAccounts?: BankAccountCreateNestedManyWithoutVendorInput
    addresses?: AddressCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutVendorInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutVendorInput
    addresses?: AddressUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUpdateManyWithoutVendorInput
    bankAccounts?: BankAccountUpdateManyWithoutVendorInput
    addresses?: AddressUpdateManyWithoutVendorInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutVendorInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutVendorInput
    addresses?: AddressUncheckedUpdateManyWithoutVendorInput
  }

  export type VendorCreateManyInput = {
    id?: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateInput = {
    requester: UserCreateNestedOneWithoutPurchaseRequestsInput
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendor: VendorCreateNestedOneWithoutPurchaseRequestsInput
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedCreateInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUpdateInput = {
    requester?: UserUpdateOneRequiredWithoutPurchaseRequestsInput
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseRequestsInput
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateManyInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseRequestUpdateManyMutationInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateInput = {
    emailApprover: string
    status: boolean
    purchase: PurchaseRequestCreateNestedOneWithoutApprovalsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalUncheckedCreateInput = {
    emailApprover: string
    status: boolean
    purchaseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalUpdateInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    purchase?: PurchaseRequestUpdateOneRequiredWithoutApprovalsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    purchaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateManyInput = {
    emailApprover: string
    status: boolean
    purchaseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalUpdateManyMutationInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    purchaseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    vendor: VendorCreateNestedOneWithoutBankAccountsInput
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUncheckedCreateInput = {
    vendorId: number
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateInput = {
    vendor?: VendorUpdateOneRequiredWithoutBankAccountsInput
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateManyInput = {
    vendorId: number
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    code: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    code: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutCityInput
  }

  export type CityCreateManyInput = {
    code: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutStateInput
  }

  export type StateUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutStateInput
  }

  export type StateCreateManyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutCountryInput
  }

  export type CountryUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutCountryInput
  }

  export type CountryCreateManyInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    vendor: VendorCreateNestedOneWithoutAddressesInput
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    city: CityCreateNestedOneWithoutAddressesInput
    state: StateCreateNestedOneWithoutAddressesInput
    country: CountryCreateNestedOneWithoutAddressesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    vendor?: VendorUpdateOneRequiredWithoutAddressesInput
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressesInput
    state?: StateUpdateOneRequiredWithoutAddressesInput
    country?: CountryUpdateOneRequiredWithoutAddressesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    stateId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    stateId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypeItemCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeItemMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeItemMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CostCenterCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostCenterMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyCountryCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyCountryMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeyCountryMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type TypeItemRelationFilter = {
    is?: TypeItemWhereInput
    isNot?: TypeItemWhereInput
  }

  export type CostCenterRelationFilter = {
    is?: CostCenterWhereInput
    isNot?: CostCenterWhereInput
  }

  export type KeyCountryRelationFilter = {
    is?: KeyCountryWhereInput
    isNot?: KeyCountryWhereInput
  }

  export type PurchaseRequestRelationFilter = {
    is?: PurchaseRequestWhereInput
    isNot?: PurchaseRequestWhereInput
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    ccId?: SortOrder
    kcId?: SortOrder
    purchaseId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    ccId?: SortOrder
    kcId?: SortOrder
    purchaseId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    ccId?: SortOrder
    kcId?: SortOrder
    purchaseId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    quantity?: SortOrder
    priceUnit?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type PurchaseRequestListRelationFilter = {
    every?: PurchaseRequestWhereInput
    some?: PurchaseRequestWhereInput
    none?: PurchaseRequestWhereInput
  }

  export type PurchaseRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    codeSap?: SortOrder
    name?: SortOrder
    fiscalTaxId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    codeSap?: SortOrder
    name?: SortOrder
    fiscalTaxId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    codeSap?: SortOrder
    name?: SortOrder
    fiscalTaxId?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EnumRequestTypeFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeFilter | RequestType
  }

  export type EnumConditionFilter = {
    equals?: Condition
    in?: Enumerable<Condition>
    notIn?: Enumerable<Condition>
    not?: NestedEnumConditionFilter | Condition
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type EnumPurchaseStatusFilter = {
    equals?: PurchaseStatus
    in?: Enumerable<PurchaseStatus>
    notIn?: Enumerable<PurchaseStatus>
    not?: NestedEnumPurchaseStatusFilter | PurchaseStatus
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    type?: SortOrder
    delivery?: SortOrder
    description?: SortOrder
    totalContract?: SortOrder
    startContract?: SortOrder
    endContract?: SortOrder
    contract?: SortOrder
    vendorId?: SortOrder
    observation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    totalContract?: SortOrder
    vendorId?: SortOrder
  }

  export type PurchaseRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    type?: SortOrder
    delivery?: SortOrder
    description?: SortOrder
    totalContract?: SortOrder
    startContract?: SortOrder
    endContract?: SortOrder
    contract?: SortOrder
    vendorId?: SortOrder
    observation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    type?: SortOrder
    delivery?: SortOrder
    description?: SortOrder
    totalContract?: SortOrder
    startContract?: SortOrder
    endContract?: SortOrder
    contract?: SortOrder
    vendorId?: SortOrder
    observation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseRequestSumOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    totalContract?: SortOrder
    vendorId?: SortOrder
  }

  export type EnumRequestTypeWithAggregatesFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeWithAggregatesFilter | RequestType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestTypeFilter
    _max?: NestedEnumRequestTypeFilter
  }

  export type EnumConditionWithAggregatesFilter = {
    equals?: Condition
    in?: Enumerable<Condition>
    notIn?: Enumerable<Condition>
    not?: NestedEnumConditionWithAggregatesFilter | Condition
    _count?: NestedIntFilter
    _min?: NestedEnumConditionFilter
    _max?: NestedEnumConditionFilter
  }

  export type EnumPurchaseStatusWithAggregatesFilter = {
    equals?: PurchaseStatus
    in?: Enumerable<PurchaseStatus>
    notIn?: Enumerable<PurchaseStatus>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter | PurchaseStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPurchaseStatusFilter
    _max?: NestedEnumPurchaseStatusFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ApprovalEmailApproverPurchaseIdCompoundUniqueInput = {
    emailApprover: string
    purchaseId: number
  }

  export type ApprovalCountOrderByAggregateInput = {
    emailApprover?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalAvgOrderByAggregateInput = {
    purchaseId?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    emailApprover?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    emailApprover?: SortOrder
    status?: SortOrder
    purchaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalSumOrderByAggregateInput = {
    purchaseId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type BankAccountCountOrderByAggregateInput = {
    vendorId?: SortOrder
    codeBank?: SortOrder
    branch?: SortOrder
    account?: SortOrder
    digit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    vendorId?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    vendorId?: SortOrder
    codeBank?: SortOrder
    branch?: SortOrder
    account?: SortOrder
    digit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    vendorId?: SortOrder
    codeBank?: SortOrder
    branch?: SortOrder
    account?: SortOrder
    digit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    vendorId?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    code?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    code?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    vendorId?: SortOrder
    addressType?: SortOrder
    street?: SortOrder
    streetNo?: SortOrder
    complement?: SortOrder
    zipCode?: SortOrder
    block?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    vendorId?: SortOrder
    streetNo?: SortOrder
    cityId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    vendorId?: SortOrder
    addressType?: SortOrder
    street?: SortOrder
    streetNo?: SortOrder
    complement?: SortOrder
    zipCode?: SortOrder
    block?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    vendorId?: SortOrder
    addressType?: SortOrder
    street?: SortOrder
    streetNo?: SortOrder
    complement?: SortOrder
    zipCode?: SortOrder
    block?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    countryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    vendorId?: SortOrder
    streetNo?: SortOrder
    cityId?: SortOrder
  }

  export type ItemCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ItemUpdateManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutCcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCcInput>, Enumerable<ItemUncheckedCreateWithoutCcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCcInput>
    createMany?: ItemCreateManyCcInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutCcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCcInput>, Enumerable<ItemUncheckedCreateWithoutCcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCcInput>
    createMany?: ItemCreateManyCcInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutCcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCcInput>, Enumerable<ItemUncheckedCreateWithoutCcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCcInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCcInput>
    createMany?: ItemCreateManyCcInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCcInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCcInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutCcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCcInput>, Enumerable<ItemUncheckedCreateWithoutCcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCcInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCcInput>
    createMany?: ItemCreateManyCcInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCcInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCcInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutKcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutKcInput>, Enumerable<ItemUncheckedCreateWithoutKcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutKcInput>
    createMany?: ItemCreateManyKcInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutKcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutKcInput>, Enumerable<ItemUncheckedCreateWithoutKcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutKcInput>
    createMany?: ItemCreateManyKcInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutKcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutKcInput>, Enumerable<ItemUncheckedCreateWithoutKcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutKcInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutKcInput>
    createMany?: ItemCreateManyKcInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutKcInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutKcInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutKcInput = {
    create?: XOR<Enumerable<ItemCreateWithoutKcInput>, Enumerable<ItemUncheckedCreateWithoutKcInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutKcInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutKcInput>
    createMany?: ItemCreateManyKcInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutKcInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutKcInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type TypeItemCreateNestedOneWithoutTypeItemsInput = {
    create?: XOR<TypeItemCreateWithoutTypeItemsInput, TypeItemUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: TypeItemCreateOrConnectWithoutTypeItemsInput
    connect?: TypeItemWhereUniqueInput
  }

  export type CostCenterCreateNestedOneWithoutTypeItemsInput = {
    create?: XOR<CostCenterCreateWithoutTypeItemsInput, CostCenterUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutTypeItemsInput
    connect?: CostCenterWhereUniqueInput
  }

  export type KeyCountryCreateNestedOneWithoutTypeItemsInput = {
    create?: XOR<KeyCountryCreateWithoutTypeItemsInput, KeyCountryUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: KeyCountryCreateOrConnectWithoutTypeItemsInput
    connect?: KeyCountryWhereUniqueInput
  }

  export type PurchaseRequestCreateNestedOneWithoutTypeItemsInput = {
    create?: XOR<PurchaseRequestCreateWithoutTypeItemsInput, PurchaseRequestUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutTypeItemsInput
    connect?: PurchaseRequestWhereUniqueInput
  }

  export type TypeItemUpdateOneRequiredWithoutTypeItemsInput = {
    create?: XOR<TypeItemCreateWithoutTypeItemsInput, TypeItemUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: TypeItemCreateOrConnectWithoutTypeItemsInput
    upsert?: TypeItemUpsertWithoutTypeItemsInput
    connect?: TypeItemWhereUniqueInput
    update?: XOR<TypeItemUpdateWithoutTypeItemsInput, TypeItemUncheckedUpdateWithoutTypeItemsInput>
  }

  export type CostCenterUpdateOneRequiredWithoutTypeItemsInput = {
    create?: XOR<CostCenterCreateWithoutTypeItemsInput, CostCenterUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: CostCenterCreateOrConnectWithoutTypeItemsInput
    upsert?: CostCenterUpsertWithoutTypeItemsInput
    connect?: CostCenterWhereUniqueInput
    update?: XOR<CostCenterUpdateWithoutTypeItemsInput, CostCenterUncheckedUpdateWithoutTypeItemsInput>
  }

  export type KeyCountryUpdateOneRequiredWithoutTypeItemsInput = {
    create?: XOR<KeyCountryCreateWithoutTypeItemsInput, KeyCountryUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: KeyCountryCreateOrConnectWithoutTypeItemsInput
    upsert?: KeyCountryUpsertWithoutTypeItemsInput
    connect?: KeyCountryWhereUniqueInput
    update?: XOR<KeyCountryUpdateWithoutTypeItemsInput, KeyCountryUncheckedUpdateWithoutTypeItemsInput>
  }

  export type PurchaseRequestUpdateOneRequiredWithoutTypeItemsInput = {
    create?: XOR<PurchaseRequestCreateWithoutTypeItemsInput, PurchaseRequestUncheckedCreateWithoutTypeItemsInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutTypeItemsInput
    upsert?: PurchaseRequestUpsertWithoutTypeItemsInput
    connect?: PurchaseRequestWhereUniqueInput
    update?: XOR<PurchaseRequestUpdateWithoutTypeItemsInput, PurchaseRequestUncheckedUpdateWithoutTypeItemsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchaseRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutRequesterInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutRequesterInput>
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutRequesterInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutRequesterInput>
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
  }

  export type PurchaseRequestUpdateManyWithoutRequesterInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutRequesterInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    set?: Enumerable<PurchaseRequestWhereUniqueInput>
    disconnect?: Enumerable<PurchaseRequestWhereUniqueInput>
    delete?: Enumerable<PurchaseRequestWhereUniqueInput>
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
    update?: Enumerable<PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<PurchaseRequestUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<PurchaseRequestScalarWhereInput>
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutRequesterInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutRequesterInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    set?: Enumerable<PurchaseRequestWhereUniqueInput>
    disconnect?: Enumerable<PurchaseRequestWhereUniqueInput>
    delete?: Enumerable<PurchaseRequestWhereUniqueInput>
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
    update?: Enumerable<PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<PurchaseRequestUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<PurchaseRequestScalarWhereInput>
  }

  export type PurchaseRequestCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutVendorInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutVendorInput>
    createMany?: PurchaseRequestCreateManyVendorInputEnvelope
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
  }

  export type BankAccountCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<BankAccountCreateWithoutVendorInput>, Enumerable<BankAccountUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<BankAccountCreateOrConnectWithoutVendorInput>
    createMany?: BankAccountCreateManyVendorInputEnvelope
    connect?: Enumerable<BankAccountWhereUniqueInput>
  }

  export type AddressCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<AddressCreateWithoutVendorInput>, Enumerable<AddressUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutVendorInput>
    createMany?: AddressCreateManyVendorInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutVendorInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutVendorInput>
    createMany?: PurchaseRequestCreateManyVendorInputEnvelope
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
  }

  export type BankAccountUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<BankAccountCreateWithoutVendorInput>, Enumerable<BankAccountUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<BankAccountCreateOrConnectWithoutVendorInput>
    createMany?: BankAccountCreateManyVendorInputEnvelope
    connect?: Enumerable<BankAccountWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<AddressCreateWithoutVendorInput>, Enumerable<AddressUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutVendorInput>
    createMany?: AddressCreateManyVendorInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type PurchaseRequestUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutVendorInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<PurchaseRequestUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: PurchaseRequestCreateManyVendorInputEnvelope
    set?: Enumerable<PurchaseRequestWhereUniqueInput>
    disconnect?: Enumerable<PurchaseRequestWhereUniqueInput>
    delete?: Enumerable<PurchaseRequestWhereUniqueInput>
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
    update?: Enumerable<PurchaseRequestUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<PurchaseRequestUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<PurchaseRequestScalarWhereInput>
  }

  export type BankAccountUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<BankAccountCreateWithoutVendorInput>, Enumerable<BankAccountUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<BankAccountCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<BankAccountUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: BankAccountCreateManyVendorInputEnvelope
    set?: Enumerable<BankAccountWhereUniqueInput>
    disconnect?: Enumerable<BankAccountWhereUniqueInput>
    delete?: Enumerable<BankAccountWhereUniqueInput>
    connect?: Enumerable<BankAccountWhereUniqueInput>
    update?: Enumerable<BankAccountUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<BankAccountUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<BankAccountScalarWhereInput>
  }

  export type AddressUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<AddressCreateWithoutVendorInput>, Enumerable<AddressUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: AddressCreateManyVendorInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<PurchaseRequestCreateWithoutVendorInput>, Enumerable<PurchaseRequestUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<PurchaseRequestCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<PurchaseRequestUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: PurchaseRequestCreateManyVendorInputEnvelope
    set?: Enumerable<PurchaseRequestWhereUniqueInput>
    disconnect?: Enumerable<PurchaseRequestWhereUniqueInput>
    delete?: Enumerable<PurchaseRequestWhereUniqueInput>
    connect?: Enumerable<PurchaseRequestWhereUniqueInput>
    update?: Enumerable<PurchaseRequestUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<PurchaseRequestUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<PurchaseRequestScalarWhereInput>
  }

  export type BankAccountUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<BankAccountCreateWithoutVendorInput>, Enumerable<BankAccountUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<BankAccountCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<BankAccountUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: BankAccountCreateManyVendorInputEnvelope
    set?: Enumerable<BankAccountWhereUniqueInput>
    disconnect?: Enumerable<BankAccountWhereUniqueInput>
    delete?: Enumerable<BankAccountWhereUniqueInput>
    connect?: Enumerable<BankAccountWhereUniqueInput>
    update?: Enumerable<BankAccountUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<BankAccountUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<BankAccountScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<AddressCreateWithoutVendorInput>, Enumerable<AddressUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: AddressCreateManyVendorInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPurchaseRequestsInput = {
    create?: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPurchaseRequestsInput = {
    create?: XOR<VendorCreateWithoutPurchaseRequestsInput, VendorUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseRequestsInput
    connect?: VendorWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ItemCreateWithoutPurchaseInput>, Enumerable<ItemUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutPurchaseInput>
    createMany?: ItemCreateManyPurchaseInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ApprovalCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ApprovalCreateWithoutPurchaseInput>, Enumerable<ApprovalUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ApprovalCreateOrConnectWithoutPurchaseInput>
    createMany?: ApprovalCreateManyPurchaseInputEnvelope
    connect?: Enumerable<ApprovalWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ItemCreateWithoutPurchaseInput>, Enumerable<ItemUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutPurchaseInput>
    createMany?: ItemCreateManyPurchaseInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ApprovalUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ApprovalCreateWithoutPurchaseInput>, Enumerable<ApprovalUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ApprovalCreateOrConnectWithoutPurchaseInput>
    createMany?: ApprovalCreateManyPurchaseInputEnvelope
    connect?: Enumerable<ApprovalWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseRequestsInput = {
    create?: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseRequestsInput
    upsert?: UserUpsertWithoutPurchaseRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPurchaseRequestsInput, UserUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type EnumRequestTypeFieldUpdateOperationsInput = {
    set?: RequestType
  }

  export type EnumConditionFieldUpdateOperationsInput = {
    set?: Condition
  }

  export type VendorUpdateOneRequiredWithoutPurchaseRequestsInput = {
    create?: XOR<VendorCreateWithoutPurchaseRequestsInput, VendorUncheckedCreateWithoutPurchaseRequestsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseRequestsInput
    upsert?: VendorUpsertWithoutPurchaseRequestsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutPurchaseRequestsInput, VendorUncheckedUpdateWithoutPurchaseRequestsInput>
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: PurchaseStatus
  }

  export type ItemUpdateManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ItemCreateWithoutPurchaseInput>, Enumerable<ItemUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutPurchaseInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutPurchaseInput>
    createMany?: ItemCreateManyPurchaseInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutPurchaseInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutPurchaseInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ApprovalUpdateManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ApprovalCreateWithoutPurchaseInput>, Enumerable<ApprovalUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ApprovalCreateOrConnectWithoutPurchaseInput>
    upsert?: Enumerable<ApprovalUpsertWithWhereUniqueWithoutPurchaseInput>
    createMany?: ApprovalCreateManyPurchaseInputEnvelope
    set?: Enumerable<ApprovalWhereUniqueInput>
    disconnect?: Enumerable<ApprovalWhereUniqueInput>
    delete?: Enumerable<ApprovalWhereUniqueInput>
    connect?: Enumerable<ApprovalWhereUniqueInput>
    update?: Enumerable<ApprovalUpdateWithWhereUniqueWithoutPurchaseInput>
    updateMany?: Enumerable<ApprovalUpdateManyWithWhereWithoutPurchaseInput>
    deleteMany?: Enumerable<ApprovalScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ItemCreateWithoutPurchaseInput>, Enumerable<ItemUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutPurchaseInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutPurchaseInput>
    createMany?: ItemCreateManyPurchaseInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutPurchaseInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutPurchaseInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ApprovalUncheckedUpdateManyWithoutPurchaseInput = {
    create?: XOR<Enumerable<ApprovalCreateWithoutPurchaseInput>, Enumerable<ApprovalUncheckedCreateWithoutPurchaseInput>>
    connectOrCreate?: Enumerable<ApprovalCreateOrConnectWithoutPurchaseInput>
    upsert?: Enumerable<ApprovalUpsertWithWhereUniqueWithoutPurchaseInput>
    createMany?: ApprovalCreateManyPurchaseInputEnvelope
    set?: Enumerable<ApprovalWhereUniqueInput>
    disconnect?: Enumerable<ApprovalWhereUniqueInput>
    delete?: Enumerable<ApprovalWhereUniqueInput>
    connect?: Enumerable<ApprovalWhereUniqueInput>
    update?: Enumerable<ApprovalUpdateWithWhereUniqueWithoutPurchaseInput>
    updateMany?: Enumerable<ApprovalUpdateManyWithWhereWithoutPurchaseInput>
    deleteMany?: Enumerable<ApprovalScalarWhereInput>
  }

  export type PurchaseRequestCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovalsInput, PurchaseRequestUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovalsInput
    connect?: PurchaseRequestWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PurchaseRequestUpdateOneRequiredWithoutApprovalsInput = {
    create?: XOR<PurchaseRequestCreateWithoutApprovalsInput, PurchaseRequestUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutApprovalsInput
    upsert?: PurchaseRequestUpsertWithoutApprovalsInput
    connect?: PurchaseRequestWhereUniqueInput
    update?: XOR<PurchaseRequestUpdateWithoutApprovalsInput, PurchaseRequestUncheckedUpdateWithoutApprovalsInput>
  }

  export type VendorCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<VendorCreateWithoutBankAccountsInput, VendorUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutBankAccountsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutBankAccountsInput = {
    create?: XOR<VendorCreateWithoutBankAccountsInput, VendorUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutBankAccountsInput
    upsert?: VendorUpsertWithoutBankAccountsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutBankAccountsInput, VendorUncheckedUpdateWithoutBankAccountsInput>
  }

  export type AddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCityInput>, Enumerable<AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCityInput>
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCityInput>, Enumerable<AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCityInput>
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCityInput>, Enumerable<AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: AddressCreateManyCityInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCityInput>, Enumerable<AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: AddressCreateManyCityInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCountryInput>, Enumerable<AddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCountryInput>
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCountryInput>, Enumerable<AddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCountryInput>
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutCountryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCountryInput>, Enumerable<AddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutCountryInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCountryInput>, Enumerable<AddressUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type VendorCreateNestedOneWithoutAddressesInput = {
    create?: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAddressesInput
    connect?: VendorWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    connect?: CityWhereUniqueInput
  }

  export type StateCreateNestedOneWithoutAddressesInput = {
    create?: XOR<StateCreateWithoutAddressesInput, StateUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: StateCreateOrConnectWithoutAddressesInput
    connect?: StateWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressesInput
    connect?: CountryWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAddressesInput
    upsert?: VendorUpsertWithoutAddressesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutAddressesInput, VendorUncheckedUpdateWithoutAddressesInput>
  }

  export type CityUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    upsert?: CityUpsertWithoutAddressesInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type StateUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<StateCreateWithoutAddressesInput, StateUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: StateCreateOrConnectWithoutAddressesInput
    upsert?: StateUpsertWithoutAddressesInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutAddressesInput, StateUncheckedUpdateWithoutAddressesInput>
  }

  export type CountryUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressesInput
    upsert?: CountryUpsertWithoutAddressesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutAddressesInput, CountryUncheckedUpdateWithoutAddressesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumRequestTypeFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeFilter | RequestType
  }

  export type NestedEnumConditionFilter = {
    equals?: Condition
    in?: Enumerable<Condition>
    notIn?: Enumerable<Condition>
    not?: NestedEnumConditionFilter | Condition
  }

  export type NestedEnumPurchaseStatusFilter = {
    equals?: PurchaseStatus
    in?: Enumerable<PurchaseStatus>
    notIn?: Enumerable<PurchaseStatus>
    not?: NestedEnumPurchaseStatusFilter | PurchaseStatus
  }

  export type NestedEnumRequestTypeWithAggregatesFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeWithAggregatesFilter | RequestType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestTypeFilter
    _max?: NestedEnumRequestTypeFilter
  }

  export type NestedEnumConditionWithAggregatesFilter = {
    equals?: Condition
    in?: Enumerable<Condition>
    notIn?: Enumerable<Condition>
    not?: NestedEnumConditionWithAggregatesFilter | Condition
    _count?: NestedIntFilter
    _min?: NestedEnumConditionFilter
    _max?: NestedEnumConditionFilter
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter = {
    equals?: PurchaseStatus
    in?: Enumerable<PurchaseStatus>
    notIn?: Enumerable<PurchaseStatus>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter | PurchaseStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPurchaseStatusFilter
    _max?: NestedEnumPurchaseStatusFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type ItemCreateWithoutTypeInput = {
    cc: CostCenterCreateNestedOneWithoutTypeItemsInput
    kc: KeyCountryCreateNestedOneWithoutTypeItemsInput
    purchase: PurchaseRequestCreateNestedOneWithoutTypeItemsInput
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutTypeInput = {
    id?: number
    ccId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutTypeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTypeInput, ItemUncheckedCreateWithoutTypeInput>
  }

  export type ItemCreateManyTypeInputEnvelope = {
    data: Enumerable<ItemCreateManyTypeInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutTypeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutTypeInput, ItemUncheckedUpdateWithoutTypeInput>
    create: XOR<ItemCreateWithoutTypeInput, ItemUncheckedCreateWithoutTypeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutTypeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutTypeInput, ItemUncheckedUpdateWithoutTypeInput>
  }

  export type ItemUpdateManyWithWhereWithoutTypeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTypeItemsInput>
  }

  export type ItemScalarWhereInput = {
    AND?: Enumerable<ItemScalarWhereInput>
    OR?: Enumerable<ItemScalarWhereInput>
    NOT?: Enumerable<ItemScalarWhereInput>
    id?: IntFilter | number
    typeId?: StringFilter | string
    ccId?: StringFilter | string
    kcId?: StringFilter | string
    purchaseId?: IntFilter | number
    description?: StringFilter | string
    quantity?: IntFilter | number
    priceUnit?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ItemCreateWithoutCcInput = {
    type: TypeItemCreateNestedOneWithoutTypeItemsInput
    kc: KeyCountryCreateNestedOneWithoutTypeItemsInput
    purchase: PurchaseRequestCreateNestedOneWithoutTypeItemsInput
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutCcInput = {
    id?: number
    typeId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutCcInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCcInput, ItemUncheckedCreateWithoutCcInput>
  }

  export type ItemCreateManyCcInputEnvelope = {
    data: Enumerable<ItemCreateManyCcInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutCcInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCcInput, ItemUncheckedUpdateWithoutCcInput>
    create: XOR<ItemCreateWithoutCcInput, ItemUncheckedCreateWithoutCcInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCcInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCcInput, ItemUncheckedUpdateWithoutCcInput>
  }

  export type ItemUpdateManyWithWhereWithoutCcInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTypeItemsInput>
  }

  export type ItemCreateWithoutKcInput = {
    type: TypeItemCreateNestedOneWithoutTypeItemsInput
    cc: CostCenterCreateNestedOneWithoutTypeItemsInput
    purchase: PurchaseRequestCreateNestedOneWithoutTypeItemsInput
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutKcInput = {
    id?: number
    typeId: string
    ccId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutKcInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutKcInput, ItemUncheckedCreateWithoutKcInput>
  }

  export type ItemCreateManyKcInputEnvelope = {
    data: Enumerable<ItemCreateManyKcInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutKcInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutKcInput, ItemUncheckedUpdateWithoutKcInput>
    create: XOR<ItemCreateWithoutKcInput, ItemUncheckedCreateWithoutKcInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutKcInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutKcInput, ItemUncheckedUpdateWithoutKcInput>
  }

  export type ItemUpdateManyWithWhereWithoutKcInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTypeItemsInput>
  }

  export type TypeItemCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeItemUncheckedCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeItemCreateOrConnectWithoutTypeItemsInput = {
    where: TypeItemWhereUniqueInput
    create: XOR<TypeItemCreateWithoutTypeItemsInput, TypeItemUncheckedCreateWithoutTypeItemsInput>
  }

  export type CostCenterCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterUncheckedCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCenterCreateOrConnectWithoutTypeItemsInput = {
    where: CostCenterWhereUniqueInput
    create: XOR<CostCenterCreateWithoutTypeItemsInput, CostCenterUncheckedCreateWithoutTypeItemsInput>
  }

  export type KeyCountryCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyCountryUncheckedCreateWithoutTypeItemsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyCountryCreateOrConnectWithoutTypeItemsInput = {
    where: KeyCountryWhereUniqueInput
    create: XOR<KeyCountryCreateWithoutTypeItemsInput, KeyCountryUncheckedCreateWithoutTypeItemsInput>
  }

  export type PurchaseRequestCreateWithoutTypeItemsInput = {
    requester: UserCreateNestedOneWithoutPurchaseRequestsInput
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendor: VendorCreateNestedOneWithoutPurchaseRequestsInput
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvals?: ApprovalCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedCreateWithoutTypeItemsInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateOrConnectWithoutTypeItemsInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutTypeItemsInput, PurchaseRequestUncheckedCreateWithoutTypeItemsInput>
  }

  export type TypeItemUpsertWithoutTypeItemsInput = {
    update: XOR<TypeItemUpdateWithoutTypeItemsInput, TypeItemUncheckedUpdateWithoutTypeItemsInput>
    create: XOR<TypeItemCreateWithoutTypeItemsInput, TypeItemUncheckedCreateWithoutTypeItemsInput>
  }

  export type TypeItemUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeItemUncheckedUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUpsertWithoutTypeItemsInput = {
    update: XOR<CostCenterUpdateWithoutTypeItemsInput, CostCenterUncheckedUpdateWithoutTypeItemsInput>
    create: XOR<CostCenterCreateWithoutTypeItemsInput, CostCenterUncheckedCreateWithoutTypeItemsInput>
  }

  export type CostCenterUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCenterUncheckedUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyCountryUpsertWithoutTypeItemsInput = {
    update: XOR<KeyCountryUpdateWithoutTypeItemsInput, KeyCountryUncheckedUpdateWithoutTypeItemsInput>
    create: XOR<KeyCountryCreateWithoutTypeItemsInput, KeyCountryUncheckedCreateWithoutTypeItemsInput>
  }

  export type KeyCountryUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyCountryUncheckedUpdateWithoutTypeItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpsertWithoutTypeItemsInput = {
    update: XOR<PurchaseRequestUpdateWithoutTypeItemsInput, PurchaseRequestUncheckedUpdateWithoutTypeItemsInput>
    create: XOR<PurchaseRequestCreateWithoutTypeItemsInput, PurchaseRequestUncheckedCreateWithoutTypeItemsInput>
  }

  export type PurchaseRequestUpdateWithoutTypeItemsInput = {
    requester?: UserUpdateOneRequiredWithoutPurchaseRequestsInput
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseRequestsInput
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: ApprovalUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutTypeItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: ApprovalUncheckedUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateWithoutRequesterInput = {
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendor: VendorCreateNestedOneWithoutPurchaseRequestsInput
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedCreateWithoutRequesterInput = {
    id?: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateOrConnectWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseRequestCreateManyRequesterInputEnvelope = {
    data: Enumerable<PurchaseRequestCreateManyRequesterInput>
    skipDuplicates?: boolean
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutRequesterInput, PurchaseRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutRequesterInput, PurchaseRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutPurchaseRequestsInput>
  }

  export type PurchaseRequestScalarWhereInput = {
    AND?: Enumerable<PurchaseRequestScalarWhereInput>
    OR?: Enumerable<PurchaseRequestScalarWhereInput>
    NOT?: Enumerable<PurchaseRequestScalarWhereInput>
    id?: IntFilter | number
    requesterId?: IntFilter | number
    type?: EnumRequestTypeFilter | RequestType
    delivery?: EnumConditionFilter | Condition
    description?: StringFilter | string
    totalContract?: IntFilter | number
    startContract?: DateTimeFilter | Date | string
    endContract?: DateTimeFilter | Date | string
    contract?: StringFilter | string
    vendorId?: IntFilter | number
    observation?: StringFilter | string
    status?: EnumPurchaseStatusFilter | PurchaseStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PurchaseRequestCreateWithoutVendorInput = {
    requester: UserCreateNestedOneWithoutPurchaseRequestsInput
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedCreateWithoutVendorInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateOrConnectWithoutVendorInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutVendorInput, PurchaseRequestUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseRequestCreateManyVendorInputEnvelope = {
    data: Enumerable<PurchaseRequestCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutVendorInput = {
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutVendorInput = {
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutVendorInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutVendorInput, BankAccountUncheckedCreateWithoutVendorInput>
  }

  export type BankAccountCreateManyVendorInputEnvelope = {
    data: Enumerable<BankAccountCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutVendorInput = {
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    city: CityCreateNestedOneWithoutAddressesInput
    state: StateCreateNestedOneWithoutAddressesInput
    country: CountryCreateNestedOneWithoutAddressesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutVendorInput = {
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutVendorInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutVendorInput, AddressUncheckedCreateWithoutVendorInput>
  }

  export type AddressCreateManyVendorInputEnvelope = {
    data: Enumerable<AddressCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutVendorInput, PurchaseRequestUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseRequestCreateWithoutVendorInput, PurchaseRequestUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutVendorInput, PurchaseRequestUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutPurchaseRequestsInput>
  }

  export type BankAccountUpsertWithWhereUniqueWithoutVendorInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutVendorInput, BankAccountUncheckedUpdateWithoutVendorInput>
    create: XOR<BankAccountCreateWithoutVendorInput, BankAccountUncheckedCreateWithoutVendorInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutVendorInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutVendorInput, BankAccountUncheckedUpdateWithoutVendorInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutVendorInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutBankAccountsInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: Enumerable<BankAccountScalarWhereInput>
    OR?: Enumerable<BankAccountScalarWhereInput>
    NOT?: Enumerable<BankAccountScalarWhereInput>
    vendorId?: IntFilter | number
    codeBank?: StringFilter | string
    branch?: StringFilter | string
    account?: StringFilter | string
    digit?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutVendorInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutVendorInput, AddressUncheckedUpdateWithoutVendorInput>
    create: XOR<AddressCreateWithoutVendorInput, AddressUncheckedCreateWithoutVendorInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutVendorInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutVendorInput, AddressUncheckedUpdateWithoutVendorInput>
  }

  export type AddressUpdateManyWithWhereWithoutVendorInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    vendorId?: IntFilter | number
    addressType?: StringFilter | string
    street?: StringFilter | string
    streetNo?: IntFilter | number
    complement?: StringFilter | string
    zipCode?: StringFilter | string
    block?: StringFilter | string
    cityId?: IntFilter | number
    stateId?: StringFilter | string
    countryId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutPurchaseRequestsInput = {
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutPurchaseRequestsInput = {
    id?: number
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutPurchaseRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type VendorCreateWithoutPurchaseRequestsInput = {
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccounts?: BankAccountCreateNestedManyWithoutVendorInput
    addresses?: AddressCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseRequestsInput = {
    id?: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutVendorInput
    addresses?: AddressUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseRequestsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseRequestsInput, VendorUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type ItemCreateWithoutPurchaseInput = {
    type: TypeItemCreateNestedOneWithoutTypeItemsInput
    cc: CostCenterCreateNestedOneWithoutTypeItemsInput
    kc: KeyCountryCreateNestedOneWithoutTypeItemsInput
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutPurchaseInput = {
    id?: number
    typeId: string
    ccId: string
    kcId: string
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutPurchaseInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseInput, ItemUncheckedCreateWithoutPurchaseInput>
  }

  export type ItemCreateManyPurchaseInputEnvelope = {
    data: Enumerable<ItemCreateManyPurchaseInput>
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutPurchaseInput = {
    emailApprover: string
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalUncheckedCreateWithoutPurchaseInput = {
    emailApprover: string
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateOrConnectWithoutPurchaseInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutPurchaseInput, ApprovalUncheckedCreateWithoutPurchaseInput>
  }

  export type ApprovalCreateManyPurchaseInputEnvelope = {
    data: Enumerable<ApprovalCreateManyPurchaseInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPurchaseRequestsInput = {
    update: XOR<UserUpdateWithoutPurchaseRequestsInput, UserUncheckedUpdateWithoutPurchaseRequestsInput>
    create: XOR<UserCreateWithoutPurchaseRequestsInput, UserUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type UserUpdateWithoutPurchaseRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutPurchaseRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpsertWithoutPurchaseRequestsInput = {
    update: XOR<VendorUpdateWithoutPurchaseRequestsInput, VendorUncheckedUpdateWithoutPurchaseRequestsInput>
    create: XOR<VendorCreateWithoutPurchaseRequestsInput, VendorUncheckedCreateWithoutPurchaseRequestsInput>
  }

  export type VendorUpdateWithoutPurchaseRequestsInput = {
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccounts?: BankAccountUpdateManyWithoutVendorInput
    addresses?: AddressUpdateManyWithoutVendorInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutVendorInput
    addresses?: AddressUncheckedUpdateManyWithoutVendorInput
  }

  export type ItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutPurchaseInput, ItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<ItemCreateWithoutPurchaseInput, ItemUncheckedCreateWithoutPurchaseInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutPurchaseInput, ItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type ItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTypeItemsInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutPurchaseInput, ApprovalUncheckedUpdateWithoutPurchaseInput>
    create: XOR<ApprovalCreateWithoutPurchaseInput, ApprovalUncheckedCreateWithoutPurchaseInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutPurchaseInput, ApprovalUncheckedUpdateWithoutPurchaseInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutPurchaseInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutApprovalsInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: Enumerable<ApprovalScalarWhereInput>
    OR?: Enumerable<ApprovalScalarWhereInput>
    NOT?: Enumerable<ApprovalScalarWhereInput>
    emailApprover?: StringFilter | string
    status?: BoolFilter | boolean
    purchaseId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PurchaseRequestCreateWithoutApprovalsInput = {
    requester: UserCreateNestedOneWithoutPurchaseRequestsInput
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendor: VendorCreateNestedOneWithoutPurchaseRequestsInput
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedCreateWithoutApprovalsInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    typeItems?: ItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseRequestCreateOrConnectWithoutApprovalsInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutApprovalsInput, PurchaseRequestUncheckedCreateWithoutApprovalsInput>
  }

  export type PurchaseRequestUpsertWithoutApprovalsInput = {
    update: XOR<PurchaseRequestUpdateWithoutApprovalsInput, PurchaseRequestUncheckedUpdateWithoutApprovalsInput>
    create: XOR<PurchaseRequestCreateWithoutApprovalsInput, PurchaseRequestUncheckedCreateWithoutApprovalsInput>
  }

  export type PurchaseRequestUpdateWithoutApprovalsInput = {
    requester?: UserUpdateOneRequiredWithoutPurchaseRequestsInput
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseRequestsInput
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutApprovalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutPurchaseInput
  }

  export type VendorCreateWithoutBankAccountsInput = {
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutVendorInput
    addresses?: AddressCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutBankAccountsInput = {
    id?: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutVendorInput
    addresses?: AddressUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutBankAccountsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutBankAccountsInput, VendorUncheckedCreateWithoutBankAccountsInput>
  }

  export type VendorUpsertWithoutBankAccountsInput = {
    update: XOR<VendorUpdateWithoutBankAccountsInput, VendorUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<VendorCreateWithoutBankAccountsInput, VendorUncheckedCreateWithoutBankAccountsInput>
  }

  export type VendorUpdateWithoutBankAccountsInput = {
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUpdateManyWithoutVendorInput
    addresses?: AddressUpdateManyWithoutVendorInput
  }

  export type VendorUncheckedUpdateWithoutBankAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutVendorInput
    addresses?: AddressUncheckedUpdateManyWithoutVendorInput
  }

  export type AddressCreateWithoutCityInput = {
    vendor: VendorCreateNestedOneWithoutAddressesInput
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    state: StateCreateNestedOneWithoutAddressesInput
    country: CountryCreateNestedOneWithoutAddressesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutCityInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutCityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressCreateManyCityInputEnvelope = {
    data: Enumerable<AddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
  }

  export type AddressUpdateManyWithWhereWithoutCityInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressCreateWithoutStateInput = {
    vendor: VendorCreateNestedOneWithoutAddressesInput
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    city: CityCreateNestedOneWithoutAddressesInput
    country: CountryCreateNestedOneWithoutAddressesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutStateInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutStateInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutStateInput, AddressUncheckedCreateWithoutStateInput>
  }

  export type AddressCreateManyStateInputEnvelope = {
    data: Enumerable<AddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutStateInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutStateInput, AddressUncheckedUpdateWithoutStateInput>
    create: XOR<AddressCreateWithoutStateInput, AddressUncheckedCreateWithoutStateInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutStateInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutStateInput, AddressUncheckedUpdateWithoutStateInput>
  }

  export type AddressUpdateManyWithWhereWithoutStateInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressCreateWithoutCountryInput = {
    vendor: VendorCreateNestedOneWithoutAddressesInput
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    city: CityCreateNestedOneWithoutAddressesInput
    state: StateCreateNestedOneWithoutAddressesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutCountryInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutCountryInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressCreateManyCountryInputEnvelope = {
    data: Enumerable<AddressCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
  }

  export type AddressUpdateManyWithWhereWithoutCountryInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type VendorCreateWithoutAddressesInput = {
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestCreateNestedManyWithoutVendorInput
    bankAccounts?: BankAccountCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAddressesInput = {
    id?: number
    codeSap: string
    name: string
    fiscalTaxId: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseRequests?: PurchaseRequestUncheckedCreateNestedManyWithoutVendorInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAddressesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
  }

  export type CityCreateWithoutAddressesInput = {
    code: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUncheckedCreateWithoutAddressesInput = {
    code: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateOrConnectWithoutAddressesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type StateCreateWithoutAddressesInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateUncheckedCreateWithoutAddressesInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StateCreateOrConnectWithoutAddressesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutAddressesInput, StateUncheckedCreateWithoutAddressesInput>
  }

  export type CountryCreateWithoutAddressesInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateWithoutAddressesInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryCreateOrConnectWithoutAddressesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
  }

  export type VendorUpsertWithoutAddressesInput = {
    update: XOR<VendorUpdateWithoutAddressesInput, VendorUncheckedUpdateWithoutAddressesInput>
    create: XOR<VendorCreateWithoutAddressesInput, VendorUncheckedCreateWithoutAddressesInput>
  }

  export type VendorUpdateWithoutAddressesInput = {
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUpdateManyWithoutVendorInput
    bankAccounts?: BankAccountUpdateManyWithoutVendorInput
  }

  export type VendorUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeSap?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fiscalTaxId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseRequests?: PurchaseRequestUncheckedUpdateManyWithoutVendorInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutVendorInput
  }

  export type CityUpsertWithoutAddressesInput = {
    update: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type CityUpdateWithoutAddressesInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutAddressesInput = {
    code?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUpsertWithoutAddressesInput = {
    update: XOR<StateUpdateWithoutAddressesInput, StateUncheckedUpdateWithoutAddressesInput>
    create: XOR<StateCreateWithoutAddressesInput, StateUncheckedCreateWithoutAddressesInput>
  }

  export type StateUpdateWithoutAddressesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutAddressesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUpsertWithoutAddressesInput = {
    update: XOR<CountryUpdateWithoutAddressesInput, CountryUncheckedUpdateWithoutAddressesInput>
    create: XOR<CountryCreateWithoutAddressesInput, CountryUncheckedCreateWithoutAddressesInput>
  }

  export type CountryUpdateWithoutAddressesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutAddressesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyTypeInput = {
    id?: number
    ccId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutTypeInput = {
    cc?: CostCenterUpdateOneRequiredWithoutTypeItemsInput
    kc?: KeyCountryUpdateOneRequiredWithoutTypeItemsInput
    purchase?: PurchaseRequestUpdateOneRequiredWithoutTypeItemsInput
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ccId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyWithoutTypeItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ccId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyCcInput = {
    id?: number
    typeId: string
    kcId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutCcInput = {
    type?: TypeItemUpdateOneRequiredWithoutTypeItemsInput
    kc?: KeyCountryUpdateOneRequiredWithoutTypeItemsInput
    purchase?: PurchaseRequestUpdateOneRequiredWithoutTypeItemsInput
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutCcInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyKcInput = {
    id?: number
    typeId: string
    ccId: string
    purchaseId: number
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutKcInput = {
    type?: TypeItemUpdateOneRequiredWithoutTypeItemsInput
    cc?: CostCenterUpdateOneRequiredWithoutTypeItemsInput
    purchase?: PurchaseRequestUpdateOneRequiredWithoutTypeItemsInput
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutKcInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: StringFieldUpdateOperationsInput | string
    ccId?: StringFieldUpdateOperationsInput | string
    purchaseId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateManyRequesterInput = {
    id?: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    vendorId: number
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseRequestUpdateWithoutRequesterInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseRequestsInput
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutPurchaseRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    vendorId?: IntFieldUpdateOperationsInput | number
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateManyVendorInput = {
    id?: number
    requesterId: number
    type: RequestType
    delivery: Condition
    description: string
    totalContract: number
    startContract: Date | string
    endContract: Date | string
    contract: string
    observation: string
    status: PurchaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateManyVendorInput = {
    codeBank: string
    branch: string
    account: string
    digit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyVendorInput = {
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseRequestUpdateWithoutVendorInput = {
    requester?: UserUpdateOneRequiredWithoutPurchaseRequestsInput
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUpdateManyWithoutPurchaseInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    requesterId?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    delivery?: EnumConditionFieldUpdateOperationsInput | Condition
    description?: StringFieldUpdateOperationsInput | string
    totalContract?: IntFieldUpdateOperationsInput | number
    startContract?: DateTimeFieldUpdateOperationsInput | Date | string
    endContract?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    observation?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | PurchaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeItems?: ItemUncheckedUpdateManyWithoutPurchaseInput
    approvals?: ApprovalUncheckedUpdateManyWithoutPurchaseInput
  }

  export type BankAccountUpdateWithoutVendorInput = {
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutVendorInput = {
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyWithoutBankAccountsInput = {
    codeBank?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    digit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutVendorInput = {
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressesInput
    state?: StateUpdateOneRequiredWithoutAddressesInput
    country?: CountryUpdateOneRequiredWithoutAddressesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutVendorInput = {
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    stateId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutAddressesInput = {
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    stateId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyPurchaseInput = {
    id?: number
    typeId: string
    ccId: string
    kcId: string
    description: string
    quantity: number
    priceUnit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateManyPurchaseInput = {
    emailApprover: string
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutPurchaseInput = {
    type?: TypeItemUpdateOneRequiredWithoutTypeItemsInput
    cc?: CostCenterUpdateOneRequiredWithoutTypeItemsInput
    kc?: KeyCountryUpdateOneRequiredWithoutTypeItemsInput
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeId?: StringFieldUpdateOperationsInput | string
    ccId?: StringFieldUpdateOperationsInput | string
    kcId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceUnit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutPurchaseInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateWithoutPurchaseInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyWithoutApprovalsInput = {
    emailApprover?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyCityInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    stateId: string
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutCityInput = {
    vendor?: VendorUpdateOneRequiredWithoutAddressesInput
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutAddressesInput
    country?: CountryUpdateOneRequiredWithoutAddressesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutCityInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyStateInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    countryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutStateInput = {
    vendor?: VendorUpdateOneRequiredWithoutAddressesInput
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressesInput
    country?: CountryUpdateOneRequiredWithoutAddressesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutStateInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    countryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyCountryInput = {
    vendorId: number
    addressType: string
    street: string
    streetNo: number
    complement: string
    zipCode: string
    block: string
    cityId: number
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutCountryInput = {
    vendor?: VendorUpdateOneRequiredWithoutAddressesInput
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressesInput
    state?: StateUpdateOneRequiredWithoutAddressesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutCountryInput = {
    vendorId?: IntFieldUpdateOperationsInput | number
    addressType?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    streetNo?: IntFieldUpdateOperationsInput | number
    complement?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}